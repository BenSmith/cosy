#!/usr/bin/bash
# cosy - podman wrapper to insulate containers
#
# Copyright (c) 2025 Ben Smith
# SPDX-License-Identifier: MIT
# See LICENSE file for full license text
#
# Architecture: 4-category model
#   1. New Commands (cosy-specific)
#   2. Intercepted Flags (flags that podman uses that cosy also uses)
#   3. Passthrough Flags (unknown to cosy)
#   4. Automatic Behaviors
# shellcheck disable=SC2155

set -euo pipefail

# ==============================================================================
# CONFIGURATION
# ==============================================================================

COSY_VERSION="1.0.0-dev"
COSY_DEFAULT_IMAGE="fedora:43"

# Bootstrap script configuration
BOOTSTRAP_APPEND_PATH="${COSY_BOOTSTRAP_APPEND_SCRIPT:-}"
BOOTSTRAP_SCRIPT_PATH="${COSY_BOOTSTRAP_SCRIPT:-}"

# Container homes directory
COSY_CONTAINER_HOMES_DIR="${COSY_HOMES_DIR:-$HOME/.local/share/cosy}"

# Audio configuration
COSY_AUDIO_DEFAULT="${COSY_AUDIO:-false}"

# D-Bus configuration
COSY_DBUS_DEFAULT="${COSY_DBUS:-false}"
COSY_DBUS_SYSTEM_DEFAULT="${COSY_DBUS_SYSTEM:-false}"

# Accessibility configuration
COSY_A11Y_DEFAULT="${COSY_A11Y:-false}"

# Display configuration
COSY_DISPLAY_DEFAULT="${COSY_DISPLAY:-true}"

# GPU configuration
COSY_GPU_DEFAULT="${COSY_GPU:-false}"

# Input device configuration
COSY_INPUT_DEFAULT="${COSY_INPUT:-false}"

# Network configuration
COSY_NETWORK_DEFAULT="${COSY_NETWORK:-default}"

# Podman socket configuration
COSY_PODMAN_DEFAULT="${COSY_PODMAN:-false}"

# Systemd configuration (matches podman default: true = auto-detect)
COSY_SYSTEMD_DEFAULT="${COSY_SYSTEMD:-true}"

# Container init configuration
# Note: COSY_CMD_DEFAULT uses intentional word-splitting to support multi-argument
# commands like "sleep infinity". The value is expanded unquoted when passed to podman.
COSY_ENTRYPOINT_DEFAULT="${COSY_ENTRYPOINT:-}"
COSY_CMD_DEFAULT="${COSY_CMD:-sleep infinity}"

# Sudo configuration
COSY_SUDO_DEFAULT="${COSY_SUDO:-false}"

# Debug mode
DEBUG="${COSY_DEBUG:-false}"

# Default container image
DEFAULT_IMAGE="${COSY_IMAGE:-$COSY_DEFAULT_IMAGE}"

# Dry run mode
DRY_RUN="${COSY_DRY_RUN:-false}"

# Logging
ENABLE_LOGGING="${COSY_LOG:-false}"
LOG_FILE="${COSY_LOG_FILE:-$HOME/.local/share/cosy/cosy.log}"

# Command history logging (opt-in)
COSY_COMMAND_HISTORY="${COSY_COMMAND_HISTORY:-false}"
COSY_COMMAND_HISTORY_FILE="${COSY_COMMAND_HISTORY_FILE:-$HOME/.local/share/cosy/command-history.jsonl}"

# ==============================================================================
# TIMEOUT AND DELAY CONSTANTS
# ==============================================================================

# Container startup timeouts and intervals
readonly CONTAINER_START_TIMEOUT_SEC=60           # Max time to wait for container to start
readonly CONTAINER_START_STATUS_INTERVAL_SEC=30   # Interval for showing startup status messages
readonly CONTAINER_WAIT_POLL_SEC=1                # Poll interval when waiting for container state
readonly CONTAINER_INIT_DELAY_SEC=1               # Additional delay after container reaches running state

# Network monitoring intervals
readonly NETWORK_WATCH_POLL_SEC=1                 # Poll interval for network watch command

# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

# log - Write timestamped message to log file if logging enabled
#
# Args:
#   $* - message to log
#
# Returns:
#   0 always
#
# Notes:
#   Logging is controlled by ENABLE_LOGGING variable
#   Log messages are written to LOG_FILE with timestamp
log() {
    if [ "$ENABLE_LOGGING" = "true" ]; then
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $*" >> "$LOG_FILE"
    fi
}

# check_required_commands - Verify all required system commands are available
#
# Returns:
#   0 if all required commands found, 1 otherwise
#
# Notes:
#   Checks for: podman, id, date, mkdir, basename, dirname
#   Prints error message to stderr if any commands are missing
check_required_commands() {
    local missing=()
    local cmd
    for cmd in podman id date mkdir basename dirname; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing required commands: ${missing[*]}" >&2
        echo "Please install the required packages to use cosy" >&2
        return 1
    fi
    return 0
}

# validate_container_name - Check if container name matches allowed pattern
#
# Args:
#   $1 - container name to validate
#
# Returns:
#   0 if name is valid, 1 if invalid
#
# Notes:
#   Valid names contain only letters, numbers, hyphens, and underscores
#   Prints error message to stderr if validation fails
validate_container_name() {
    local name="$1"
    if ! [[ "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Error: Invalid container name '$name'" >&2
        echo "Container names must contain only letters, numbers, hyphens, and underscores"
        return 1
    fi
    return 0
}

# require_container_name - Require container name to be provided
#
# Args:
#   $1 - container name (to check if empty)
#   $2 - usage message (optional)
#
# Returns:
#   0 if name is provided, exits with 1 if empty
require_container_name() {
    local name="$1"
    local usage="${2:-Usage: cosy COMMAND CONTAINER_NAME}"

    if [ -z "$name" ]; then
        echo "Error: Container name required" >&2
        echo "$usage" >&2
        exit 1
    fi
}

# require_container_exists - Require container to exist
#
# Args:
#   $1 - container name
#   $2 - custom error message (optional)
#
# Returns:
#   0 if container exists, exits with 1 if not
require_container_exists() {
    local name="$1"
    local custom_msg="${2:-}"

    if ! podman container exists "$name" 2>/dev/null; then
        if [ -n "$custom_msg" ]; then
            echo "$custom_msg" >&2
        else
            echo "Error: Container '$name' does not exist" >&2
            echo "Use 'cosy create $name' to create it" >&2
        fi
        exit 1
    fi
}

# require_container_not_exists - Require container to not exist
#
# Args:
#   $1 - container name
#
# Returns:
#   0 if container doesn't exist, exits with 1 if exists
require_container_not_exists() {
    local name="$1"

    if podman container exists "$name" 2>/dev/null; then
        echo "Error: Container '$name' already exists" >&2
        echo "Use 'cosy enter $name' to enter it" >&2
        echo "Or 'cosy rm $name' to remove it first" >&2
        exit 1
    fi
}

# container_exists - Check if container exists (non-exiting version)
#
# Args:
#   $1 - container name
#
# Returns:
#   0 if container exists, 1 if not
container_exists() {
    local name="$1"
    podman container exists "$name" 2>/dev/null
}

# get_container_pid - Get the process ID of a running container
#
# Args:
#   $1 - container name
#
# Outputs:
#   Container PID to stdout, or empty string if not found
#
# Returns:
#   0 on success, 1 if container not found
get_container_pid() {
    local container="$1"
    podman inspect --format '{{.State.Pid}}' "$container" 2>/dev/null
}

# wait_for_container_running - Wait for a container to reach running state
#
# Args:
#   $1 - container name
#
# Returns:
#   0 if container reaches running state, 1 on timeout
#
# Notes:
#   Waits up to CONTAINER_START_TIMEOUT_SEC for container to start
#   Shows status messages at CONTAINER_START_STATUS_INTERVAL_SEC intervals
wait_for_container_running() {
    local container="$1"
    local waited=0

    while true; do
        local state=$(podman inspect -f '{{.State.Status}}' "$container" 2>/dev/null || echo "unknown")
        if [ "$state" = "running" ]; then
            # Additional short delay to ensure init process is ready
            sleep "$CONTAINER_INIT_DELAY_SEC"
            return 0
        fi

        # Show status message at regular intervals
        if [ $((waited % CONTAINER_START_STATUS_INTERVAL_SEC)) -eq 0 ] && [ $waited -gt 0 ]; then
            echo "Still waiting for container to start (${waited}s elapsed)..." >&2
        fi

        sleep "$CONTAINER_WAIT_POLL_SEC"
        waited=$((waited + 1))

        # Timeout after configured duration
        if [ $waited -ge "$CONTAINER_START_TIMEOUT_SEC" ]; then
            echo "Error: Container failed to start after ${CONTAINER_START_TIMEOUT_SEC} seconds (state: $state)" >&2
            echo "Check container logs with: podman logs $container" >&2
            return 1
        fi
    done
}

# list_home_directories - List all container home directory names
#
# Outputs:
#   Sorted list of home directory names (one per line) to stdout
#
# Returns:
#   0 always
#
# Notes:
#   Returns empty output if COSY_CONTAINER_HOMES_DIR doesn't exist
#   Only lists directories, not files
list_home_directories() {
    if [ ! -d "$COSY_CONTAINER_HOMES_DIR" ]; then
        return 0
    fi

    find "$COSY_CONTAINER_HOMES_DIR" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort
}

run_quiet() {
    if [ "$DEBUG" = true ]; then
        "$@"
    else
        "$@" 2>/dev/null
    fi
}

# run_in_container_netns - Run command in container's network namespace
#
# Args:
#   $1 - container name
#   $@ - command and arguments to run in network namespace
#
# Returns:
#   0 on success, 1 if container not running or PID unavailable
#
# Notes:
#   Uses podman unshare + nsenter to work in rootless mode
#   Container must be running to obtain PID
run_in_container_netns() {
    local container="$1"
    shift

    local pid
    pid=$(get_container_pid "$container")

    if [ -z "$pid" ] || [ "$pid" = "0" ]; then
        echo "Error: Could not get PID for container '$container'" >&2
        echo "Container may not be running" >&2
        return 1
    fi

    # Use podman unshare to enter user namespace, then nsenter for network namespace
    # This works in rootless mode without requiring sudo
    # -n = network namespace
    # -t = target PID
    podman unshare nsenter -n -t "$pid" "$@"
}

# ==============================================================================
# COMMAND HISTORY LOGGING
# ==============================================================================

# generate_session_id - Generate unique session identifier
#
# Outputs:
#   UUID string to stdout (uuidgen if available, otherwise timestamp-random)
#
# Returns:
#   0 always
#
# Notes:
#   Prefers uuidgen if available, falls back to timestamp + random number
generate_session_id() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen | tr -d '\n'
    else
        # Fallback: timestamp + random
        echo "$(date +%s)-$(od -An -N4 -tu4 /dev/urandom 2>/dev/null | tr -d ' ')"
    fi
}

# get_or_create_session_id - Get existing or generate new session ID
#
# Args:
#   $1 - container name (optional)
#
# Outputs:
#   Session ID to stdout (existing from container or newly generated)
#
# Returns:
#   0 always
#
# Notes:
#   Checks container label cosy.session_id if container exists
#   Generates new session ID if container doesn't exist or has no session
get_or_create_session_id() {
    local container="${1:-}"

    # Try to get existing session from container
    # Use 'command' to bypass the podman wrapper to avoid logging these queries
    if [ -n "$container" ] && container_exists "$container"; then
        local existing_session
        existing_session=$(command podman inspect --format '{{index .Config.Labels "cosy.session_id"}}' "$container" 2>/dev/null)
        if [ -n "$existing_session" ] && [ "$existing_session" != "<no value>" ]; then
            echo "$existing_session"
            return
        fi
    fi

    generate_session_id
}

generate_invocation_id() {
    echo "$(date +%s%N)-$$"
}

# ==============================================================================
# DESKTOP INTEGRATION HELPER FUNCTIONS
# ==============================================================================

get_desktop_metadata_dir() {
    local container="$1"
    echo "${COSY_CONTAINER_HOMES_DIR}/${container}"
}

get_desktop_metadata_file() {
    local container="$1"
    echo "$(get_desktop_metadata_dir "$container")/.desktop-metadata"
}

get_desktop_file_path() {
    local container="$1"
    echo "$HOME/.local/share/applications/cosy-${container}.desktop"
}

# Check if a desktop entry exists for a container
desktop_entry_exists() {
    local container="$1"
    [ -f "$(get_desktop_metadata_file "$container")" ]
}

# Escape string for JSON format
# Handles: backslashes, quotes, newlines, carriage returns, tabs
json_escape() {
    local str="$1"
    # Order matters: backslashes first, then others
    str="${str//\\/\\\\}"        # \ -> \\
    str="${str//\"/\\\"}"        # " -> \"
    str="${str//$'\n'/\\n}"      # newline -> \n
    str="${str//$'\r'/\\r}"      # carriage return -> \r
    str="${str//$'\t'/\\t}"      # tab -> \t
    echo "$str"
}

# Escape string for desktop file format
# Handles: backslashes, semicolons, newlines
desktop_escape() {
    local str="$1"
    str="${str//\\/\\\\}"        # \ -> \\
    str="${str//\"/\\\"}"        # " -> \"
    str="${str//;/\\;}"          # ; -> \; (semicolon is field separator)
    str="${str//$'\n'/\\n}"      # newline -> \n
    echo "$str"
}

# Convert bash array to JSON array
array_to_json() {
    local arr=("$@")
    local json="["
    for ((i=0; i<${#arr[@]}; i++)); do
        if [ $i -gt 0 ]; then
            json+=","
        fi
        # Escape for JSON (order matters: backslashes first, then others)
        local escaped="${arr[$i]//\\/\\\\}"  # \ -> \\
        escaped="${escaped//\"/\\\"}"        # " -> \"
        escaped="${escaped//$'\n'/\\n}"      # newline -> \n
        escaped="${escaped//$'\r'/\\r}"      # carriage return -> \r
        escaped="${escaped//$'\t'/\\t}"      # tab -> \t
        escaped="${escaped//$'\b'/\\b}"      # backspace -> \b
        escaped="${escaped//$'\f'/\\f}"      # form feed -> \f
        json+="\"$escaped\""
    done
    json+="]"
    echo "$json"
}

# log_command_history - Log podman command execution to history file
#
# Args:
#   $1 - podman command name (e.g., "create", "start", "exec")
#   $2 - podman arguments as JSON array
#   $3 - exit code (optional, omitted if not provided)
#   $4 - duration in milliseconds (optional, omitted if not provided)
#
# Returns:
#   0 always
#
# Notes:
#   Only logs if COSY_COMMAND_HISTORY is "true"
#   Writes JSON format log entry to COSY_COMMAND_HISTORY_FILE
#   Includes session ID, invocation ID, version, and feature metadata
log_command_history() {
    [ "$COSY_COMMAND_HISTORY" != "true" ] && return 0

    local podman_cmd="$1"
    shift
    local podman_args_json="$1"
    shift
    local exit_code="${1:-}"
    local duration_ms="${2:-}"

    COMMAND_HISTORY_SEQUENCE=$((COMMAND_HISTORY_SEQUENCE + 1))

    local json="{"
    json+="\"version\":\"1.0\","
    json+="\"timestamp\":\"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\","

    # Session ID (may be empty for non-container commands)
    if [ -n "${COMMAND_HISTORY_SESSION_ID:-}" ]; then
        json+="\"session_id\":\"$COMMAND_HISTORY_SESSION_ID\","
    fi

    json+="\"invocation_id\":\"$COMMAND_HISTORY_INVOCATION_ID\","
    json+="\"sequence\":$COMMAND_HISTORY_SEQUENCE,"
    json+="\"cosy_version\":\"$COSY_VERSION\","

    if [ -n "${COMMAND_HISTORY_COSY_COMMAND:-}" ]; then
        json+="\"cosy_command\":\"$COMMAND_HISTORY_COSY_COMMAND\","
    fi

    if [ -n "${COMMAND_HISTORY_COSY_ARGS:-}" ]; then
        json+="\"cosy_args\":$COMMAND_HISTORY_COSY_ARGS,"
    fi

    json+="\"podman_command\":\"$podman_cmd\","
    json+="\"podman_args\":$podman_args_json"

    if [ -n "${COSY_CONTAINER_NAME:-}" ]; then
        json+=",\"container_name\":\"$COSY_CONTAINER_NAME\""
    fi

    if [ -n "${COMMAND_HISTORY_IMAGE:-}" ]; then
        json+=",\"image\":\"$COMMAND_HISTORY_IMAGE\""
    fi

    if [ -n "${COMMAND_HISTORY_IMAGE_ID:-}" ]; then
        json+=",\"image_id\":\"$COMMAND_HISTORY_IMAGE_ID\""
    fi

    if [ -n "${COMMAND_HISTORY_FEATURES:-}" ]; then
        json+=",\"features\":$COMMAND_HISTORY_FEATURES"
    fi

    if [ -n "$exit_code" ]; then
        json+=",\"exit_code\":$exit_code"
    fi

    if [ -n "$duration_ms" ]; then
        json+=",\"duration_ms\":$duration_ms"
    fi

    json+="}"

    local log_dir
    log_dir=$(dirname "$COSY_COMMAND_HISTORY_FILE")
    mkdir -p "$log_dir" 2>/dev/null || true

    # Append to log file (ignore errors to not break cosy)
    echo "$json" >> "$COSY_COMMAND_HISTORY_FILE" 2>/dev/null || true
}

build_features_json() {
    local json="{"
    json+="\"a11y\":${ENABLE_A11Y:-false},"
    json+="\"audio\":${ENABLE_AUDIO:-false},"
    json+="\"dbus\":${ENABLE_DBUS:-false},"
    json+="\"dbus_system\":${ENABLE_DBUS_SYSTEM:-false},"
    json+="\"display\":${ENABLE_DISPLAY:-true},"
    json+="\"gpu\":${ENABLE_GPU:-false},"

    if [ "${DISABLE_NETWORK:-false}" = true ]; then
        json+="\"network\":\"none\","
    elif [ "${ENABLE_HOST_NETWORK:-false}" = true ]; then
        json+="\"network\":\"host\","
    elif [ -n "${CUSTOM_NETWORK:-}" ]; then
        json+="\"network\":\"$CUSTOM_NETWORK\","
    else
        json+="\"network\":\"default\","
    fi

    json+="\"podman\":${ENABLE_PODMAN:-false},"
    json+="\"systemd\":\"${SYSTEMD_MODE:-true}\""
    json+="}"
    echo "$json"
}

# Wrapper function for podman that adds automatic logging
# This shadows the real podman command and logs all invocations
podman() {
    # Skip logging for certain read-only commands to reduce noise
    local cmd="${1:-}"
    local subcmd="${2:-}"
    local skip_log=false

    # Only skip logging if explicitly disabled for this command
    # Most inspect/ps/exists calls are internal queries we don't need
    case "$cmd" in
        inspect|ps)
            # Only log these if they're explicit user commands (not internal queries)
            if [ "${COSY_COMMAND_HISTORY_LOG_QUERIES:-false}" != "true" ]; then
                skip_log=true
            fi
            ;;
        container)
            # Skip 'container exists' queries
            if [ "$subcmd" = "exists" ] && [ "${COSY_COMMAND_HISTORY_LOG_QUERIES:-false}" != "true" ]; then
                skip_log=true
            fi
            ;;
    esac

    local start_ms=$(date +%s%3N 2>/dev/null || echo "0")

    # Execute real podman command (using 'command' to bypass this function)
    local exit_code=0
    command podman "$@" || exit_code=$?

    local end_ms=$(date +%s%3N 2>/dev/null || echo "0")
    local duration_ms=$((end_ms - start_ms))

    if [ "$COSY_COMMAND_HISTORY" = "true" ] && [ "$skip_log" = false ]; then
        local args_json=$(array_to_json "$@")
        log_command_history "$cmd" "$args_json" "$exit_code" "$duration_ms"
    fi

    return $exit_code
}

# ==============================================================================
# FEATURE MODULE INTERFACE
# ==============================================================================

FEATURES=(a11y audio dbus dbus_system display gpu input podman)

# Standard interface that each feature module must implement:
#
# feature_${name}_parse "$@"
#   - Parse command-line flags for this feature
#   - Return 0 if flag was handled, 1 if not recognized
#   - Modify state variables (e.g., ENABLE_AUDIO=true)
#   - Consume arguments by shifting in calling context
#
# feature_${name}_setup
#   - Build podman argument arrays (e.g., AUDIO_ARGS)
#   - Validate feature is available if enabled
#   - Called before container creation
#   - Uses state variables set by parse function
#
# feature_${name}_detect "$container_name"
#   - Detect if feature is enabled in existing container
#   - Used by inspect and recreate commands
#   - Set state variables based on container config
#   - Uses podman inspect to examine container
#
# feature_${name}_validate
#   - Check if feature can be used on this system
#   - Return 0 if available, 1 with warning if not
#   - Called by setup function if feature is enabled
#   - Should warn user if feature not available

# ==============================================================================
# FEATURE MODULES
# ==============================================================================
# Each feature implemented as a module with 4 standard functions:
# parse, setup, detect, validate

# ------------------------------------------------------------------------------
# FEATURE: A11Y (Accessibility Bus)
# ------------------------------------------------------------------------------
# Provides access to the host's AT-SPI accessibility bus for assistive
# technologies like screen readers.
# ------------------------------------------------------------------------------

feature_a11y_detect() {
    local container="$1"

    local a11y_label
    a11y_label=$(get_cached_label "$container" "cosy.a11y")

    if [ "$a11y_label" = "true" ]; then
        ENABLE_A11Y=true
    else
        ENABLE_A11Y=false
    fi
}

feature_a11y_parse() {
    case "$1" in
        --a11y|--accessibility)
            ENABLE_A11Y=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_a11y_setup() {
    if [ "${A11Y_ARGS+set}" != "set" ]; then
        A11Y_ARGS=()
    fi

    if [ "$ENABLE_A11Y" = true ]; then
        # AT-SPI bus can be in various locations depending on the system
        local ATSPI_DIR="$XDG_RUNTIME_DIR/at-spi"
        local ATSPI_SOCKET="$ATSPI_DIR/bus"
        local ATSPI_PATH="bus"

        # Try alternative locations
        if [ ! -S "$ATSPI_SOCKET" ] && [ -S "$ATSPI_DIR/bus_0" ]; then
            ATSPI_SOCKET="$ATSPI_DIR/bus_0"
            ATSPI_PATH="bus_0"
        elif [ ! -S "$ATSPI_SOCKET" ] && [ -S "$XDG_RUNTIME_DIR/at-spi-bus-0" ]; then
            ATSPI_SOCKET="$XDG_RUNTIME_DIR/at-spi-bus-0"
            ATSPI_DIR="$XDG_RUNTIME_DIR"
            ATSPI_PATH="at-spi-bus-0"
        fi

        if [ "$DRY_RUN" = true ] || [ -S "$ATSPI_SOCKET" ]; then
            A11Y_ARGS+=(
                -v "$ATSPI_DIR:/run/user/$HOST_UID/at-spi"
                -e "AT_SPI_BUS_ADDRESS=unix:path=/run/user/$HOST_UID/at-spi/$ATSPI_PATH"
            )
        else
            echo "Warning: AT-SPI accessibility bus socket not found" >&2
            echo "Looked in: $XDG_RUNTIME_DIR/at-spi/{bus,bus_0} and $XDG_RUNTIME_DIR/at-spi-bus-0" >&2
            echo "Accessibility features may not work properly." >&2
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.a11y=true")
    fi
}

feature_a11y_validate() {
    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: AUDIO
# ------------------------------------------------------------------------------
# Provides automatic audio device passthrough for containers.
# Detects PipeWire or PulseAudio and mounts the appropriate sockets.
# ------------------------------------------------------------------------------

feature_audio_detect() {
    local container="$1"

    local audio_label
    audio_label=$(get_cached_label "$container" "cosy.audio")

    if [ "$audio_label" = "true" ]; then
        ENABLE_AUDIO=true
    else
        ENABLE_AUDIO=false
    fi
}

feature_audio_parse() {
    case "$1" in
        --audio)
            ENABLE_AUDIO=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_audio_setup() {
    AUDIO_ARGS=()

    if [ "$ENABLE_AUDIO" = true ]; then
        # Mount audio device if it exists
        if [ -d "/dev/snd" ]; then
            AUDIO_ARGS+=(--device /dev/snd)
        fi

        if [ -S "$XDG_RUNTIME_DIR/pipewire-0" ]; then
            AUDIO_ARGS+=(
                -v "$XDG_RUNTIME_DIR/pipewire-0:/run/user/$HOST_UID/pipewire-0"
            )
        fi

        if [ -S "$XDG_RUNTIME_DIR/pulse/native" ]; then
            AUDIO_ARGS+=(
                -v "$XDG_RUNTIME_DIR/pulse:/run/user/$HOST_UID/pulse"
                -e "PULSE_SERVER=unix:/run/user/$HOST_UID/pulse/native"
            )
        fi

        if [ ${#AUDIO_ARGS[@]} -eq 0 ]; then
            echo "Warning: --audio specified but no PipeWire or PulseAudio sockets found" >&2
            echo "Audio may not work in the container." >&2
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.audio=true")
    fi
}

feature_audio_validate() {
    # Audio validation is done in setup (checks for sockets and warns)
    # No system-level validation needed
    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: D-BUS (Session)
# ------------------------------------------------------------------------------
# Provides access to the host's D-Bus session bus.
# Automatically masks the container's D-Bus services by creating symlinks to
# /dev/null in /etc/systemd/system to prevent conflicts with the host D-Bus.
# This works regardless of whether systemd is running in the container.
# ------------------------------------------------------------------------------

feature_dbus_detect() {
    local container="$1"

    local dbus_label
    dbus_label=$(get_cached_label "$container" "cosy.dbus")

    if [ "$dbus_label" = "true" ]; then
        ENABLE_DBUS=true
    else
        ENABLE_DBUS=false
    fi
}

feature_dbus_parse() {
    case "$1" in
        --dbus)
            ENABLE_DBUS=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_dbus_setup() {
    # DBUS_ARGS is shared with dbus_system
    if [ "${DBUS_ARGS+set}" != "set" ]; then
        DBUS_ARGS=()
    fi

    if [ "$ENABLE_DBUS" = true ]; then
        DBUS_SESSION_SOCKET="$XDG_RUNTIME_DIR/bus"
        if [ "$DRY_RUN" = true ] || [ -S "$DBUS_SESSION_SOCKET" ]; then
            DBUS_ARGS+=(
                -v "$DBUS_SESSION_SOCKET:/run/user/$HOST_UID/bus"
                -e "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$HOST_UID/bus"
            )
        else
            echo "Warning: D-Bus session bus socket not found at $DBUS_SESSION_SOCKET" >&2
            echo "D-Bus features may not work properly." >&2
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.dbus=true")
    fi
}

feature_dbus_validate() {
    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: D-BUS-SYSTEM
# ------------------------------------------------------------------------------
# Provides access to the host's D-Bus system bus.
# Automatically masks the container's D-Bus services by creating symlinks to
# /dev/null in /etc/systemd/system to prevent conflicts with the host D-Bus.
# This works regardless of whether systemd is running in the container.
# ------------------------------------------------------------------------------

feature_dbus_system_detect() {
    local container="$1"

    local dbus_system_label
    dbus_system_label=$(get_cached_label "$container" "cosy.dbus_system")

    if [ "$dbus_system_label" = "true" ]; then
        ENABLE_DBUS_SYSTEM=true
    else
        ENABLE_DBUS_SYSTEM=false
    fi
}

feature_dbus_system_parse() {
    case "$1" in
        --dbus-system)
            ENABLE_DBUS_SYSTEM=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_dbus_system_setup() {
    # DBUS_ARGS is shared with dbus
    if [ "${DBUS_ARGS+set}" != "set" ]; then
        DBUS_ARGS=()
    fi

    if [ "$ENABLE_DBUS_SYSTEM" = true ]; then
        DBUS_SYSTEM_SOCKET="/var/run/dbus/system_bus_socket"
        if [ "$DRY_RUN" = true ] || [ -S "$DBUS_SYSTEM_SOCKET" ]; then
            DBUS_ARGS+=(
                -v "$DBUS_SYSTEM_SOCKET:/var/run/dbus/system_bus_socket"
                -e "DBUS_SYSTEM_BUS_ADDRESS=unix:path=/var/run/dbus/system_bus_socket"
            )
        else
            echo "Warning: D-Bus system bus socket not found at $DBUS_SYSTEM_SOCKET" >&2
            echo "D-Bus system features may not work properly." >&2
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.dbus_system=true")
    fi
}

feature_dbus_system_validate() {
    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: DISPLAY
# ------------------------------------------------------------------------------
# Provides X11 and Wayland display access (automatic unless --no-display).
# ------------------------------------------------------------------------------

feature_display_detect() {
    local container="$1"

    local display_label
    display_label=$(get_cached_label "$container" "cosy.display")

    if [ "$display_label" = "true" ]; then
        ENABLE_DISPLAY=true
    else
        ENABLE_DISPLAY=false
    fi
}

feature_display_parse() {
    case "$1" in
        --no-display)
            ENABLE_DISPLAY=false
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_display_setup() {
    DISPLAY_ARGS=()

    if [ "$ENABLE_DISPLAY" = true ]; then
        local detected_display="${DISPLAY:-}"
        if [ -z "$detected_display" ]; then
            if [ -S "/tmp/.X11-unix/X0" ]; then
                detected_display=":0"
            elif [ -S "/tmp/.X11-unix/X1" ]; then
                detected_display=":1"
            fi
        fi

        DISPLAY_ARGS+=(
            -e "DISPLAY=$detected_display"
            -v "/tmp/.X11-unix:/tmp/.X11-unix:ro"
        )

        local xauth_file="${XAUTHORITY:-}"
        if [ -z "$xauth_file" ] || [ ! -f "$xauth_file" ]; then
            # Try to find .mutter-Xwaylandauth or .Xauthority in XDG_RUNTIME_DIR
            if [ -n "$XDG_RUNTIME_DIR" ] && [ -d "$XDG_RUNTIME_DIR" ]; then
                xauth_file=$(find "$XDG_RUNTIME_DIR" -maxdepth 1 -name ".mutter-Xwaylandauth.*" -type f 2>/dev/null | head -1)
            fi
            if [ -z "$xauth_file" ] && [ -f "$HOME/.Xauthority" ]; then
                xauth_file="$HOME/.Xauthority"
            fi
        fi

        if [ -n "$xauth_file" ] && [ -f "$xauth_file" ]; then
            DISPLAY_ARGS+=(
                -v "$xauth_file:/home/$HOST_USER/.Xauthority:ro"
                -e "XAUTHORITY=/home/$HOST_USER/.Xauthority"
            )
        fi

        local detected_wayland="${WAYLAND_DISPLAY:-}"
        if [ -z "$detected_wayland" ] && [ -n "$XDG_RUNTIME_DIR" ]; then
            if [ -S "$XDG_RUNTIME_DIR/wayland-0" ]; then
                detected_wayland="wayland-0"
            elif [ -S "$XDG_RUNTIME_DIR/wayland-1" ]; then
                detected_wayland="wayland-1"
            fi
        fi

        if [ -n "$detected_wayland" ] && [ -S "$XDG_RUNTIME_DIR/$detected_wayland" ]; then
            DISPLAY_ARGS+=(
                -e "WAYLAND_DISPLAY=$detected_wayland"
                -e "XDG_RUNTIME_DIR=/run/user/$HOST_UID"
                -v "$XDG_RUNTIME_DIR/$detected_wayland:/run/user/$HOST_UID/$detected_wayland:ro"
            )
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.display=true")
    fi
}

feature_display_validate() {
    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: GPU
# ------------------------------------------------------------------------------
# Provides GPU device passthrough (/dev/dri) for hardware acceleration.
# ------------------------------------------------------------------------------

feature_gpu_detect() {
    local container="$1"

    local gpu_label
    gpu_label=$(get_cached_label "$container" "cosy.gpu")

    if [ "$gpu_label" = "true" ]; then
        ENABLE_GPU=true
    else
        ENABLE_GPU=false
    fi
}

feature_gpu_parse() {
    case "$1" in
        --gpu)
            ENABLE_GPU=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_gpu_setup() {
    GPU_ARGS=()
    if [ "$ENABLE_GPU" = true ]; then
        GPU_ARGS+=(--device /dev/dri)
        # Store in label for detection (can't detect device from podman inspect)
        LABEL_ARGS+=(--label "cosy.gpu=true")
    fi
}

feature_gpu_validate() {
    if [ "$ENABLE_GPU" != true ]; then
        return 0
    fi

    # Check if /dev/dri exists
    if [ ! -d "/dev/dri" ]; then
        echo "Warning: --gpu specified but /dev/dri not found" >&2
        echo "GPU acceleration may not work." >&2
        return 0
    fi

    # Check if user has access to GPU devices
    local has_access=false
    for device in /dev/dri/card* /dev/dri/renderD*; do
        if [ -e "$device" ] && [ -r "$device" ]; then
            has_access=true
            break
        fi
    done

    if [ "$has_access" = false ]; then
        echo "Warning: --gpu specified but you don't have read access to GPU devices in /dev/dri" >&2
        echo "You may need to add your user to the 'video' and 'render' groups:" >&2
        echo "  sudo usermod -a -G video,render $HOST_USER" >&2
        echo "Then log out and log back in for the changes to take effect." >&2
    fi

    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: INPUT
# ------------------------------------------------------------------------------
# Provides access to input devices (joysticks, gamepads, keyboards, mice).
# Shares /dev/input, /dev/uinput, and /dev/hidraw* devices with the container.
# ------------------------------------------------------------------------------

feature_input_detect() {
    local container="$1"

    local input_label
    input_label=$(get_cached_label "$container" "cosy.input")

    if [ "$input_label" = "true" ]; then
        ENABLE_INPUT=true
    else
        ENABLE_INPUT=false
    fi
}

feature_input_parse() {
    case "$1" in
        --input)
            ENABLE_INPUT=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_input_setup() {
    INPUT_ARGS=()
    if [ "$ENABLE_INPUT" = true ]; then
        # Share /dev/input for standard input devices (keyboards, mice, joysticks, gamepads)
        if [ -d "/dev/input" ]; then
            INPUT_ARGS+=(--device /dev/input)
        fi

        # Share /dev/uinput for creating virtual input devices
        if [ -e "/dev/uinput" ]; then
            INPUT_ARGS+=(--device /dev/uinput)
        fi

        # Share all /dev/hidraw* devices for raw HID device access
        for hidraw in /dev/hidraw*; do
            if [ -e "$hidraw" ]; then
                INPUT_ARGS+=(--device "$hidraw")
            fi
        done

        # Store in label for detection
        LABEL_ARGS+=(--label "cosy.input=true")
    fi
}

feature_input_validate() {
    if [ "$ENABLE_INPUT" != true ]; then
        return 0
    fi

    # Check if /dev/input exists
    if [ ! -d "/dev/input" ]; then
        echo "Warning: --input specified but /dev/input not found" >&2
        echo "Input device access may not work." >&2
        return 0
    fi

    # Check if user has access to input devices
    local has_access=false
    for device in /dev/input/event* /dev/input/js* /dev/input/mouse*; do
        if [ -e "$device" ] && [ -r "$device" ]; then
            has_access=true
            break
        fi
    done

    if [ "$has_access" = false ]; then
        echo "Warning: --input specified but you don't have read access to input devices in /dev/input" >&2
        echo "You may need to add your user to the 'input' group:" >&2
        echo "  sudo usermod -a -G input $HOST_USER" >&2
        echo "Then log out and log back in for the changes to take effect." >&2
    fi

    return 0
}

# ------------------------------------------------------------------------------
# FEATURE: PODMAN (Socket)
# ------------------------------------------------------------------------------
# Provides access to the host's Podman socket for nested containers.
# ------------------------------------------------------------------------------

feature_podman_detect() {
    local container="$1"

    local podman_label
    podman_label=$(get_cached_label "$container" "cosy.podman")

    if [ "$podman_label" = "true" ]; then
        ENABLE_PODMAN=true
    else
        ENABLE_PODMAN=false
    fi
}

feature_podman_parse() {
    case "$1" in
        --podman)
            ENABLE_PODMAN=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

feature_podman_setup() {
    PODMAN_SOCKET_ARGS=()

    if [ "$ENABLE_PODMAN" = true ]; then
        PODMAN_SOCKET="/run/user/$HOST_UID/podman/podman.sock"
        if [ "$DRY_RUN" = true ] || [ -S "$PODMAN_SOCKET" ]; then
            PODMAN_SOCKET_ARGS+=(
                -v "$PODMAN_SOCKET:/run/user/$HOST_UID/podman/podman.sock"
                -e "CONTAINER_HOST=unix:///run/user/$HOST_UID/podman/podman.sock"
            )
        else
            echo "Error: Podman socket not found at $PODMAN_SOCKET" >&2
            echo "The --podman flag requires the podman socket to be available." >&2
            echo "Enable with: systemctl --user enable --now podman.socket" >&2
            exit 1
        fi

        # Store feature state in label for detection
        LABEL_ARGS+=(--label "cosy.podman=true")
    fi
}

feature_podman_validate() {
    return 0
}

# ------------------------------------------------------------------------------
# ==============================================================================
# INTERCEPTED FLAGS MODULE
# ==============================================================================
# Handles podman-native flags that cosy intercepts and validates to prevent
# or warn about conflicts with cosy's behaviors.
#
# Intercepted flags:
#   --device        (can conflict with --gpu, --input)
#   --env/-e        (cosy uses env variables for the container)
#   --label/-l      (cosy uses labels internally for metadata)
#   --network       (podman native, adds capabilities for custom networks)
#   --security-opt  (passthrough to podman)
#   --systemd       (podman native, cosy tracks explicit vs default)
#   --tmpfs         (can conflict with auto-tmpfs)
#   -v/--volume     (can conflict with auto-mounts)

# State variables for intercepted flags
# These will be initialized in init_container_vars()
# CUSTOM_NETWORK=""
# DEVICES=()
# DISABLE_NETWORK=false
# ENABLE_HOST_NETWORK=false
# EXTRA_MOUNTS=()
# SECURITY_OPTS=()
# SYSTEMD_EXPLICITLY_SET=false
# SYSTEMD_MODE=""
# USER_ENV_VARS=()
# USER_LABELS=()
# USER_TMPFS=()

# Auto-mount destinations that user volumes should not conflict with
# These are set by cosy features and should be protected
get_protected_mount_destinations() {
    local protected_paths=()

    protected_paths+=("/home/$HOST_USER")

    if [ "${ENABLE_DISPLAY:-true}" = true ]; then
        protected_paths+=(
            "/tmp/.X11-unix"
            "/home/$HOST_USER/.Xauthority"
        )
        # Wayland sockets vary, check at runtime
        if [ -n "${WAYLAND_DISPLAY:-}" ]; then
            protected_paths+=("/run/user/$HOST_UID/${WAYLAND_DISPLAY}")
        fi
    fi

    if [ "${ENABLE_AUDIO:-false}" = true ]; then
        protected_paths+=(
            "/run/user/$HOST_UID/pipewire-0"
            "/run/user/$HOST_UID/pulse"
        )
    fi

    if [ "${ENABLE_DBUS:-false}" = true ]; then
        protected_paths+=("/run/user/$HOST_UID/bus")
    fi

    if [ "${ENABLE_DBUS_SYSTEM:-false}" = true ]; then
        protected_paths+=("/var/run/dbus/system_bus_socket")
    fi

    if [ "${ENABLE_PODMAN:-false}" = true ]; then
        protected_paths+=("/run/user/$HOST_UID/podman/podman.sock")
    fi

    printf '%s\n' "${protected_paths[@]}"
}

# Auto-tmpfs paths that user should not override
get_protected_tmpfs_paths() {
    local protected=()

    # Always protected
    protected+=(
        "/tmp"
        "/run/user/$HOST_UID"
    )

    # Protected when systemd is enabled (podman --systemd handles these)
    if [ "${SYSTEMD_MODE:-false}" = "true" ] || [ "${SYSTEMD_MODE:-false}" = "always" ]; then
        protected+=(
            "/run"
            "/run/lock"
        )
    fi

    printf '%s\n' "${protected[@]}"
}

# Validation: Check if user --device conflicts with cosy features
validate_devices() {
    if [ ${#DEVICES[@]} -eq 0 ]; then
        return 0
    fi

    for device in "${DEVICES[@]}"; do
        if [ "${ENABLE_GPU:-false}" = true ] && [ "$device" = "/dev/dri" ]; then
            echo "Error: Cannot use --device /dev/dri with --gpu flag" >&2
            echo "The --gpu flag automatically adds this device." >&2
            echo "Remove either --device /dev/dri or --gpu." >&2
            exit 1
        fi

        if [ "${ENABLE_INPUT:-false}" = true ]; then
            if [ "$device" = "/dev/input" ]; then
                echo "Error: Cannot use --device /dev/input with --input flag" >&2
                echo "The --input flag automatically adds this device." >&2
                echo "Remove either --device /dev/input or --input." >&2
                exit 1
            fi

            if [ "$device" = "/dev/uinput" ]; then
                echo "Error: Cannot use --device /dev/uinput with --input flag" >&2
                echo "The --input flag automatically adds this device." >&2
                echo "Remove either --device /dev/uinput or --input." >&2
                exit 1
            fi

            if [[ "$device" == /dev/hidraw* ]]; then
                echo "Error: Cannot use --device $device with --input flag" >&2
                echo "The --input flag automatically adds all /dev/hidraw* devices." >&2
                echo "Remove either --device $device or --input." >&2
                exit 1
            fi
        fi

        # Warn if user doesn't have access to the device
        if [ -e "$device" ] && [ ! -r "$device" ]; then
            echo "Warning: --device $device specified but you don't have read access" >&2
            echo "The device may not work properly in the container." >&2

            # Provide helpful suggestions for common device types
            case "$device" in
                /dev/kvm)
                    echo "You may need to add your user to the 'kvm' group:" >&2
                    echo "  sudo usermod -a -G kvm $HOST_USER" >&2
                    ;;
                /dev/video*)
                    echo "You may need to add your user to the 'video' group:" >&2
                    echo "  sudo usermod -a -G video $HOST_USER" >&2
                    ;;
                /dev/snd/*)
                    echo "You may need to add your user to the 'audio' group:" >&2
                    echo "  sudo usermod -a -G audio $HOST_USER" >&2
                    ;;
            esac
            echo "Then log out and log back in for the changes to take effect." >&2
        fi
    done

    return 0
}

# Validation: Check if user -v/--volume conflicts with auto-mounts
validate_volumes() {
    if [ ${#EXTRA_MOUNTS[@]} -eq 0 ]; then
        return 0
    fi

    local protected_paths
    protected_paths=$(get_protected_mount_destinations)

    for mount_spec in "${EXTRA_MOUNTS[@]}"; do
        local dest
        dest=$(echo "$mount_spec" | cut -d: -f2)

        while IFS= read -r protected; do
            # Only check exact matches, not subdirectories
            # This allows mounting to /home/$USER/Pictures while protecting /home/$USER itself
            if [ "$dest" = "$protected" ]; then
                local feature=""
                case "$protected" in
                    /tmp/.X11-unix|*/.Xauthority|/run/user/*/wayland-*) feature="display (automatic)" ;;
                    /run/user/*/pipewire-*|/run/user/*/pulse) feature="--audio" ;;
                    /run/user/*/bus) feature="--dbus" ;;
                    /var/run/dbus/system_bus_socket) feature="--dbus-system" ;;
                    /run/user/*/podman/podman.sock) feature="--podman" ;;
                    /home/*) feature="home directory (automatic)" ;;
                esac

                echo "Error: Cannot mount volume to $dest" >&2
                echo "This path conflicts with cosy's $feature feature." >&2
                echo "Remove the conflicting --volume flag." >&2
                exit 1
            fi
        done <<< "$protected_paths"
    done

    return 0
}

# Validation: Check if user --tmpfs conflicts with auto-tmpfs
validate_tmpfs() {
    if [ ${#USER_TMPFS[@]} -eq 0 ]; then
        return 0
    fi

    local protected_paths
    protected_paths=$(get_protected_tmpfs_paths)

    for tmpfs_spec in "${USER_TMPFS[@]}"; do
        # Extract path from tmpfs spec (format: path or path:options)
        local path
        path=$(echo "$tmpfs_spec" | cut -d: -f1)

        while IFS= read -r protected; do
            if [ "$path" = "$protected" ]; then
                echo "Error: Cannot add tmpfs mount for $path" >&2
                echo "This path is managed automatically by cosy." >&2

                if [ "$path" = "/run" ] || [ "$path" = "/run/lock" ]; then
                    echo "These tmpfs mounts are handled by podman's --systemd flag." >&2
                fi

                echo "Remove the --tmpfs $path flag." >&2
                exit 1
            fi
        done <<< "$protected_paths"
    done

    return 0
}

validate_intercepted_flags() {
    validate_devices
    validate_volumes
    validate_tmpfs
}

# Parse intercepted flags
intercepted_device_parse() {
    case "$1" in
        --device)
            DEVICES+=("$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

intercepted_volume_parse() {
    case "$1" in
        -v|--volume)
            EXTRA_MOUNTS+=(-v "$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

intercepted_security_opt_parse() {
    case "$1" in
        --security-opt)
            SECURITY_OPTS+=("$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

intercepted_tmpfs_parse() {
    case "$1" in
        --tmpfs)
            USER_TMPFS+=("$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

intercepted_systemd_parse() {
    case "$1" in
        --systemd)
            # Accept any value and let podman validate it
            # Consume next argument as the value
            if [ -n "${2:-}" ]; then
                SYSTEMD_MODE="$2"
                SYSTEMD_EXPLICITLY_SET=true
                PARSE_CONSUMED=2
                return 0
            fi
            # If no next argument, return 1 to let it be handled as passthrough
            # (podman will error about missing value)
            return 1
            ;;
        --systemd=*)
            # Accept any value and let podman validate it
            local value="${1#*=}"
            SYSTEMD_MODE="$value"
            SYSTEMD_EXPLICITLY_SET=true
            PARSE_CONSUMED=1
            return 0
            ;;
    esac
    return 1
}

intercepted_network_parse() {
    case "$1" in
        --network)
            case "${2:-}" in
                default)
                    DISABLE_NETWORK=false
                    ENABLE_HOST_NETWORK=false
                    CUSTOM_NETWORK=""
                    ;;
                host)
                    DISABLE_NETWORK=false
                    ENABLE_HOST_NETWORK=true
                    CUSTOM_NETWORK=""
                    ;;
                none)
                    DISABLE_NETWORK=true
                    ENABLE_HOST_NETWORK=false
                    CUSTOM_NETWORK=""
                    ;;
                *)
                    # Custom bridge network
                    DISABLE_NETWORK=false
                    ENABLE_HOST_NETWORK=false
                    CUSTOM_NETWORK="${2:-}"
                    ;;
            esac
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

validate_reserved_env_var() {
    local env_spec="$1"
    local env_name="${env_spec%%=*}"

    # List of reserved environment variables that cosy uses
    local reserved_vars=(
        "AT_SPI_BUS_ADDRESS"
        "CONTAINER_HOST"
        "COSY_CONTAINER_GID"
        "COSY_CONTAINER_HOME"
        "COSY_CONTAINER_NAME"
        "COSY_CONTAINER_UID"
        "COSY_CONTAINER_USER"
        "DBUS_SESSION_BUS_ADDRESS"
        "DBUS_SYSTEM_BUS_ADDRESS"
        "DISPLAY"
        "HOME"
        "PULSE_SERVER"
        "USER"
        "WAYLAND_DISPLAY"
        "XAUTHORITY"
        "XDG_RUNTIME_DIR"
    )

    for reserved in "${reserved_vars[@]}"; do
        if [ "$env_name" = "$reserved" ]; then
            echo "Warning: Setting '$env_name' may conflict with cosy's automatic configuration" >&2
            echo "         This could cause unexpected behavior or break container functionality" >&2
            return 0
        fi
    done

    return 1
}

intercepted_label_parse() {
    case "$1" in
        --label|-l)
            # Check for reserved cosy.* namespace
            if [[ "$2" == cosy.* ]]; then
                echo "Error: Cannot set labels in the 'cosy.*' namespace" >&2
                echo "       This namespace is reserved for cosy's internal metadata" >&2
                echo "       Attempted to set: $2" >&2
                exit 1
            fi
            USER_LABELS+=("$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

intercepted_env_parse() {
    case "$1" in
        --env|-e)
            validate_reserved_env_var "$2"
            USER_ENV_VARS+=("$2")
            PARSE_CONSUMED=2
            return 0
            ;;
    esac
    return 1
}

# List of all intercepted parse functions
INTERCEPTED_PARSERS=(
    intercepted_device_parse
    intercepted_env_parse
    intercepted_label_parse
    intercepted_network_parse
    intercepted_security_opt_parse
    intercepted_systemd_parse
    intercepted_tmpfs_parse
    intercepted_volume_parse
)

# Setup functions for intercepted flags that need podman args
intercepted_systemd_setup() {
    SYSTEMD_ARGS=()
    # Only pass --systemd to podman if user explicitly set it
    if [ "$SYSTEMD_EXPLICITLY_SET" = true ]; then
        if [ -n "$SYSTEMD_MODE" ] && [ "$SYSTEMD_MODE" != "false" ]; then
            SYSTEMD_ARGS+=(--systemd="$SYSTEMD_MODE")
        elif [ "$SYSTEMD_MODE" = "false" ]; then
            SYSTEMD_ARGS+=(--systemd=false)
        fi
    fi
    # Always add label to track the effective systemd mode (for inspect/recreate)
    LABEL_ARGS+=(--label "cosy.systemd=$SYSTEMD_MODE")
}

intercepted_network_setup() {
    NETWORK_ARGS=()
    if [ "$DISABLE_NETWORK" = true ]; then
        NETWORK_ARGS+=(--network none)
    elif [ "$ENABLE_HOST_NETWORK" = true ]; then
        NETWORK_ARGS+=(--network host)
    elif [ -n "$CUSTOM_NETWORK" ]; then
        NETWORK_ARGS+=(--network "$CUSTOM_NETWORK")
    fi
}

# Detection functions for intercepted flags (used by inspect/recreate)
intercepted_systemd_detect() {
    local container="$1"

    local systemd_label
    systemd_label=$(get_cached_label "$container" "cosy.systemd")

    if [ -z "$systemd_label" ] || [ "$systemd_label" = "<no value>" ]; then
        SYSTEMD_MODE="true"
    else
        SYSTEMD_MODE="$systemd_label"
    fi
}

intercepted_network_detect() {
    local container="$1"

    local network_mode
    network_mode=$(get_cached_config "$container" '{{.HostConfig.NetworkMode}}')

    if [ -z "$network_mode" ] || [ "$network_mode" = "<no value>" ]; then
        network_mode="default"
    fi

    case "$network_mode" in
        default|bridge|pasta|"")
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK=""
            NETWORK_MODE="default"
            ;;
        host)
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=true
            CUSTOM_NETWORK=""
            NETWORK_MODE="host"
            ;;
        none)
            DISABLE_NETWORK=true
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK=""
            NETWORK_MODE="none"
            ;;
        *)
            # Custom network
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK="$network_mode"
            NETWORK_MODE="$network_mode"
            ;;
    esac
}

intercepted_detect() {
    local container="$1"

    DEVICES=()
    EXTRA_MOUNTS=()
    SECURITY_OPTS=()
    USER_ENV_VARS=()
    USER_LABELS=()
    USER_TMPFS=()

    local devices_label
    devices_label=$(get_cached_label "$container" "cosy.devices")
    if [ -n "$devices_label" ] && [ "$devices_label" != "<no value>" ]; then
        IFS=',' read -ra DEVICES <<< "$devices_label"
    fi

    local tmpfs_label
    tmpfs_label=$(get_cached_label "$container" "cosy.tmpfs")
    if [ -n "$tmpfs_label" ] && [ "$tmpfs_label" != "<no value>" ]; then
        IFS=',' read -ra USER_TMPFS <<< "$tmpfs_label"
    fi

    local labels_label
    labels_label=$(get_cached_label "$container" "cosy.user_labels")
    if [ -n "$labels_label" ] && [ "$labels_label" != "<no value>" ]; then
        IFS=',' read -ra USER_LABELS <<< "$labels_label"
    fi

    local env_label
    env_label=$(get_cached_label "$container" "cosy.user_env")
    if [ -n "$env_label" ] && [ "$env_label" != "<no value>" ]; then
        IFS=',' read -ra USER_ENV_VARS <<< "$env_label"
    fi

    local mounts_label
    mounts_label=$(get_cached_label "$container" "cosy.mounts")
    if [ -n "$mounts_label" ] && [ "$mounts_label" != "<no value>" ]; then
        IFS=',' read -ra EXTRA_MOUNTS <<< "$mounts_label"
    fi

    local sudo_label
    sudo_label=$(get_cached_label "$container" "cosy.sudo")
    if [ "$sudo_label" = "true" ]; then
        ENABLE_SUDO=true
    fi
}

# ==============================================================================
# PASSTHROUGH MANAGER
# ==============================================================================

# Array to hold unknown flags that should be passed directly to podman
PASSTHROUGH_ARGS=()

passthrough_init() {
    PASSTHROUGH_ARGS=()
}

passthrough_add_flag() {
    local flag="$1"

    # Detect if flag has a value
    if [[ "$flag" == --*=* ]]; then
        # Flag with value: --flag=value
        PASSTHROUGH_ARGS+=("$flag")
        return 1  # Consumed 1 arg
    elif [[ "$flag" == -* ]]; then
        # Check if next arg is a value or another flag
        if [[ -n "${2:-}" ]] && [[ "$2" != -* ]]; then
            # Flag with separate value: --flag value
            PASSTHROUGH_ARGS+=("$flag" "$2")
            return 2  # Signal that we consumed 2 args
        else
            # Boolean flag: --flag
            PASSTHROUGH_ARGS+=("$flag")
            return 1  # Consumed 1 arg
        fi
    fi

    return 1  # Consumed 1 arg
}

passthrough_build_args() {
    # No transformation needed, args are already in correct format
    true
}

# ==============================================================================
# AUTOMATIC BEHAVIORS
# ==============================================================================

automatic_setup_security_labels() {
    # Determine if we should add :Z labels to mounts based on security-opt settings
    # Default: disable SELinux labels (use label=disable)
    # If user specifies label=type:*, enable :Z labels automatically

    local use_labels=false
    local has_label_opt=false

    # Check if user specified any label-related security-opt
    for opt in "${SECURITY_OPTS[@]}"; do
        if [[ "$opt" == label=* ]]; then
            has_label_opt=true
            # If they're setting a type (not disable), we need :Z labels
            if [[ "$opt" == label=type:* ]]; then
                use_labels=true
            fi
        fi
    done

    # If no label security-opt was specified, default to label=disable
    if [ "$has_label_opt" = false ]; then
        SECURITY_OPTS+=("label=disable")
    fi

    # Set PRIVATE_LABEL for use in mounts
    if [ "$use_labels" = true ]; then
        PRIVATE_LABEL=":Z"
    else
        PRIVATE_LABEL=""
    fi
}

# automatic_setup_home - Configure home directory mount and environment
#
# Returns:
#   0 always
#
# Notes:
#   Sets APP_HOME to container-specific directory
#   Configures HOME_ARGS array with volume mount and environment variables
#   Home directory is created later by create_container_home_directory
automatic_setup_home() {
    APP_HOME="${COSY_CONTAINER_HOMES_DIR}/${COSY_CONTAINER_NAME}"

    HOME_ARGS=(
        -v "$APP_HOME:/home/$HOST_USER$PRIVATE_LABEL"
        -e "COSY_CONTAINER_NAME=$COSY_CONTAINER_NAME"
        -e "COSY_CONTAINER_USER=$HOST_USER"
        -e "COSY_CONTAINER_UID=$HOST_UID"
        -e "COSY_CONTAINER_GID=$HOST_GID"
        -e "COSY_CONTAINER_HOME=/home/$HOST_USER"
        -e "HOME=/home/$HOST_USER"
        -e "USER=$HOST_USER"
    )

    # Pass host group GIDs for display purposes when device access features are enabled
    # These groups are already preserved by --group-add keep-groups for actual permissions,
    # but creating them in the container improves UX by showing real group names instead of "nobody"
    # This can be disabled with --no-create-groups
    if [ "${ENABLE_GPU:-false}" = true ] || [ "${ENABLE_INPUT:-false}" = true ]; then
        # Collect all relevant group GIDs that may be needed for device access
        local group_gids=""

        # Video group (for GPU access via /dev/dri)
        if [ "${ENABLE_GPU:-false}" = true ]; then
            local video_gid
            video_gid=$(getent group video 2>/dev/null | cut -d: -f3)
            if [ -n "$video_gid" ]; then
                HOME_ARGS+=(-e "HOST_VIDEO_GID=$video_gid")
                group_gids="${group_gids:+$group_gids,}video:$video_gid"
            fi

            # Render group (for GPU rendering via /dev/dri/renderD*)
            local render_gid
            render_gid=$(getent group render 2>/dev/null | cut -d: -f3)
            if [ -n "$render_gid" ]; then
                HOME_ARGS+=(-e "HOST_RENDER_GID=$render_gid")
                group_gids="${group_gids:+$group_gids,}render:$render_gid"
            fi
        fi

        # Input group (for input device access via /dev/input)
        if [ "${ENABLE_INPUT:-false}" = true ]; then
            local input_gid
            input_gid=$(getent group input 2>/dev/null | cut -d: -f3)
            if [ -n "$input_gid" ]; then
                HOME_ARGS+=(-e "HOST_INPUT_GID=$input_gid")
                group_gids="${group_gids:+$group_gids,}input:$input_gid"
            fi
        fi

        # Store in label for recreate detection
        if [ -n "$group_gids" ]; then
            LABEL_ARGS+=(--label "cosy.host_groups=$group_gids")
        fi

        # Pass NO_CREATE_GROUPS flag to bootstrap script
        if [ "${NO_CREATE_GROUPS:-false}" = true ]; then
            HOME_ARGS+=(-e "NO_CREATE_GROUPS=true")
            LABEL_ARGS+=(--label "cosy.no_create_groups=true")
        fi
    fi

    # Store sudo configuration in label for detection/recreation
    if [ "$ENABLE_SUDO" = true ]; then
        LABEL_ARGS+=(--label "cosy.sudo=true")
    fi
}

# automatic_setup_user_namespace - Configure user namespace mapping
#
# Returns:
#   0 always
#
# Notes:
#   Maps host UID/GID into container namespace
#   Preserves host supplementary groups with keep-groups
#   Required for rootless containers to match host user identity
automatic_setup_user_namespace() {
    USER_NAMESPACE_ARGS=(
        --uidmap "+$HOST_UID:@$HOST_UID:1"
        --gidmap "+$HOST_GID:@$HOST_GID:1"
        --group-add
        keep-groups
    )
}

# automatic_setup_capabilities - Configure Linux capabilities for container
#
# Returns:
#   0 always
#
# Notes:
#   Only applies if user hasn't specified --cap-add/--cap-drop flags
#   Starts with minimal capabilities (drop ALL)
#   Adds base capabilities needed for user management
#   Adds systemd capabilities if systemd will run
#   Adds network capabilities if custom network configured
automatic_setup_capabilities() {
    # Only set capabilities if user hasn't specified any
    # This respects user's --cap-add/--cap-drop flags
    local has_cap_flags=false
    for arg in "${PASSTHROUGH_ARGS[@]}"; do
        if [[ "$arg" == "--cap-add"* ]] || [[ "$arg" == "--cap-drop"* ]]; then
            has_cap_flags=true
            break
        fi
    done

    if [ "$has_cap_flags" = true ]; then
        # User specified capabilities, don't override
        return 0
    fi

    # Start with minimal capabilities
    CAPABILITY_ARGS=(--cap-drop=ALL)

    # Base capabilities (always needed for container operation)
    CAPABILITY_ARGS+=(
        --cap-add=CHOWN           # Change file ownership
        --cap-add=DAC_OVERRIDE    # Bypass file permission checks
        --cap-add=FOWNER          # Bypass permission checks for file operations
        --cap-add=SETUID          # Set user ID (for useradd, su, etc.)
        --cap-add=SETGID          # Set group ID (for groupadd, etc.)
    )

    # Systemd requires additional capabilities
    # Check if systemd will actually be enabled (explicitly set OR auto-detected from image)
    local systemd_will_run=false
    if [ "$SYSTEMD_EXPLICITLY_SET" = true ]; then
        # User explicitly set --systemd, check if it's enabled
        if [ "$SYSTEMD_MODE" = "true" ] || [ "$SYSTEMD_MODE" = "always" ]; then
            systemd_will_run=true
        fi
    elif [ "$SYSTEMD_MODE" = "true" ]; then
        # Auto-detect mode - check if image's CMD is systemd
        local pid1_exe=$(get_pid1_executable "$IMAGE" "$CONTAINER_CMD" "$COSY_CMD_DEFAULT")
        if is_systemd_init "$pid1_exe"; then
            systemd_will_run=true
        fi
    fi

    if [ "$systemd_will_run" = true ]; then
        CAPABILITY_ARGS+=(
            --cap-add=FSETID           # Set file setuid/setgid bits
            --cap-add=KILL             # Send signals to processes
            --cap-add=NET_BIND_SERVICE # Bind to privileged ports (<1024)
            --cap-add=SETFCAP          # Set file capabilities
            --cap-add=SETPCAP          # Set process capabilities
            --cap-add=SYS_CHROOT       # Use chroot()
        )
    fi

    # Custom network requires network administration
    if [ -n "${CUSTOM_NETWORK:-}" ]; then
        CAPABILITY_ARGS+=(
            --cap-add=NET_ADMIN       # Network configuration
            --cap-add=NET_RAW         # Raw sockets (ping, traceroute)
        )
    fi
}

automatic_setup_display() {
    # Display is already handled by display feature module
    # This function is a no-op for consistency
    true
}

# automatic_setup_bootstrap - Placeholder for bootstrap setup
#
# Returns:
#   0 always
#
# Notes:
#   Bootstrap script is created and executed by run_podman_create
#   This function exists for consistency but performs no action
automatic_setup_bootstrap() {
    # Bootstrap script is created and executed after container creation
    # This function is a no-op - actual bootstrap handled in run_podman_create
    true
}

get_pid1_executable() {
    local image="$1"
    local user_cmd="${2:-}"
    local default_cmd="${3:-}"

    # User --cmd overrides everything (but not if it's just the default)
    if [ -n "$user_cmd" ] && [ "$user_cmd" != "$default_cmd" ]; then
        echo "$user_cmd" | awk '{print $1}'
        return
    fi

    local entrypoint
    entrypoint=$(podman inspect --format '{{index .Config.Entrypoint 0}}' "$image" 2>/dev/null)
    local cmd
    cmd=$(podman inspect --format '{{index .Config.Cmd 0}}' "$image" 2>/dev/null)

    # Entrypoint takes precedence over Cmd
    if [ -n "$entrypoint" ] && [ "$entrypoint" != "<no value>" ]; then
        echo "$entrypoint"
    elif [ -n "$cmd" ] && [ "$cmd" != "<no value>" ]; then
        echo "$cmd"
    fi
}

is_systemd_init() {
    local executable="$1"
    # Match podman's exact list of systemd init executables
    [[ "$executable" =~ ^(systemd|/usr/sbin/init|/sbin/init|/usr/local/sbin/init)$ ]]
}

get_image_command() {
    local image="$1"

    local entrypoint
    if ! entrypoint=$(podman inspect --format '{{join .Config.Entrypoint " "}}' "$image" 2>/dev/null); then
        return 1
    fi

    local cmd
    cmd=$(podman inspect --format '{{join .Config.Cmd " "}}' "$image" 2>/dev/null)

    # Entrypoint takes precedence; if both exist, combine them
    if [ -n "$entrypoint" ] && [ "$entrypoint" != "<no value>" ]; then
        if [ -n "$cmd" ] && [ "$cmd" != "<no value>" ]; then
            echo "$entrypoint $cmd"
        else
            echo "$entrypoint"
        fi
    elif [ -n "$cmd" ] && [ "$cmd" != "<no value>" ]; then
        echo "$cmd"
    fi
}

# apply_image_command_if_default - Use image's CMD if user didn't specify command
#
# Returns:
#   0 always
#
# Notes:
#   Only applies if user didn't set --cmd flag and COSY_CMD not set
#   Skips interactive shells that need TTY (bash, sh, zsh, etc.)
#   Allows image CMD for services (web servers, databases, init systems)
#   Sets CONTAINER_CMD to image's command if applicable
apply_image_command_if_default() {
    # Only use image's CMD if both:
    # 1. User didn't specify --cmd flag (USER_SET_CMD is false)
    # 2. COSY_CMD environment variable is not set (truly using built-in default)
    # 3. Image CMD is NOT an interactive shell that needs TTY
    if [ "${USER_SET_CMD:-false}" = false ] && [ -z "${COSY_CMD+x}" ]; then
        local image_cmd=$(get_image_command "$IMAGE")
        if [ -n "$image_cmd" ]; then
            # Skip interactive shells that exit without TTY
            # Use the image's CMD for everything else (web servers, databases, init, etc.)
            if [[ ! "$image_cmd" =~ (^/bin/(ba)?sh$|^/usr/bin/(ba)?sh$|^bash$|^sh$|^/bin/zsh$|^zsh$|^/bin/ksh$|^ksh$|^/bin/csh$|^csh$|^/bin/tcsh$|^tcsh$) ]]; then
                CONTAINER_CMD="$image_cmd"
            fi
        fi
    fi
}

automatic_setup_tmpfs() {
    # IMPORTANT: When systemd is enabled, podman's --systemd flag automatically creates
    # tmpfs mounts for /tmp, /run, and /run/lock. We must NOT add these manually or we'll
    # get duplicate mounts. Only add /run/user/$HOST_UID which is not handled by systemd.
    #
    # The --systemd flag has three modes:
    #   - false: Never enable systemd mode
    #   - true: Auto-detect based on CMD/Entrypoint (checks for systemd, /usr/sbin/init, /sbin/init, /usr/local/sbin/init)
    #   - always: Force systemd mode regardless of CMD/Entrypoint

    TMPFS_ARGS=()

    TMPFS_ARGS+=(--tmpfs "/run/user/$HOST_UID:mode=0700")

    # Determine if podman will create systemd tmpfs mounts
    # Only skip /tmp for recognized systemd modes that will create it
    local skip_tmp_tmpfs=false
    if [ "$SYSTEMD_MODE" = "always" ]; then
        # Force systemd mode - podman will create tmpfs regardless of CMD
        skip_tmp_tmpfs=true
    elif [ "$SYSTEMD_MODE" = "true" ]; then
        # Auto-detect mode - check if CMD/Entrypoint is a systemd init
        local pid1_exe=$(get_pid1_executable "$IMAGE" "$CONTAINER_CMD" "$COSY_CMD_DEFAULT")
        if is_systemd_init "$pid1_exe"; then
            skip_tmp_tmpfs=true
        fi
    fi
    # Note: For "false", empty, or any unrecognized value, we add /tmp (safest)

    # Add /tmp tmpfs unless podman's --systemd will create it
    if [ "$skip_tmp_tmpfs" = false ]; then
        TMPFS_ARGS+=(--tmpfs "/tmp")
    fi

    # Do NOT add /run or /run/lock tmpfs when systemd is enabled
    # Podman's --systemd flag handles these automatically to avoid conflicts
}

automatic_setup_intercepted_values() {
    INTERCEPTED_ARGS=()

    for device in "${DEVICES[@]}"; do
        INTERCEPTED_ARGS+=(--device "$device")
    done

    INTERCEPTED_ARGS+=("${EXTRA_MOUNTS[@]}")

    for opt in "${SECURITY_OPTS[@]}"; do
        INTERCEPTED_ARGS+=(--security-opt "$opt")
    done

    for tmpfs in "${USER_TMPFS[@]}"; do
        INTERCEPTED_ARGS+=(--tmpfs "$tmpfs")
    done

    for label in "${USER_LABELS[@]}"; do
        INTERCEPTED_ARGS+=(--label "$label")
    done

    for env in "${USER_ENV_VARS[@]}"; do
        INTERCEPTED_ARGS+=(--env "$env")
    done

    if [ ${#DEVICES[@]} -gt 0 ]; then
        local devices_joined
        devices_joined=$(IFS=,; echo "${DEVICES[*]}")
        LABEL_ARGS+=(--label "cosy.devices=$devices_joined")
    fi

    if [ ${#USER_TMPFS[@]} -gt 0 ]; then
        local tmpfs_joined
        tmpfs_joined=$(IFS=,; echo "${USER_TMPFS[*]}")
        LABEL_ARGS+=(--label "cosy.tmpfs=$tmpfs_joined")
    fi

    if [ ${#USER_LABELS[@]} -gt 0 ]; then
        local labels_joined
        labels_joined=$(IFS=,; echo "${USER_LABELS[*]}")
        LABEL_ARGS+=(--label "cosy.user_labels=$labels_joined")
    fi

    if [ ${#USER_ENV_VARS[@]} -gt 0 ]; then
        local env_joined
        env_joined=$(IFS=,; echo "${USER_ENV_VARS[*]}")
        LABEL_ARGS+=(--label "cosy.user_env=$env_joined")
    fi

    if [ ${#EXTRA_MOUNTS[@]} -gt 0 ]; then
        local mounts_joined
        mounts_joined=$(IFS=,; echo "${EXTRA_MOUNTS[*]}")
        LABEL_ARGS+=(--label "cosy.mounts=$mounts_joined")
    fi
}

automatic_setup_all() {
    # required before automatic_setup_home & automatic_setup_intercepted_values
    automatic_setup_security_labels

    automatic_setup_bootstrap
    automatic_setup_capabilities
    automatic_setup_display
    automatic_setup_home
    automatic_setup_intercepted_values
    automatic_setup_tmpfs
    automatic_setup_user_namespace
}

# ==============================================================================
# GENERIC PARSER
# ==============================================================================

# parse_container_args - Parse command-line arguments for container operations
#
# Args:
#   $@ - Command-line arguments to parse
#
# Returns:
#   0 on success, exits with 1 on parse errors
#
# Notes:
#   Implements 4-category argument parsing model:
#   1. Container name (first non-flag argument)
#   2. Feature flags (--audio, --gpu, etc.) - parsed by feature modules
#   3. Intercepted flags (--network, --systemd, etc.) - parsed by intercepted module
#   4. Passthrough flags (unknown flags) - passed directly to podman
#
#   Arguments after '--' separator are stored in EXEC_CMD for command execution
#   Sets COSY_CONTAINER_NAME and various state variables used by setup functions
parse_container_args() {
    passthrough_init
    EXEC_CMD=()
    local after_separator=false

    while [[ $# -gt 0 ]]; do
        if [ "$after_separator" = true ]; then
            EXEC_CMD+=("$1")
            shift
            continue
        fi

        if [ "$1" = "--" ]; then
            after_separator=true
            shift
            continue
        fi

        local handled=false
        PARSE_CONSUMED=0

        if [[ "$1" != -* ]]; then
            if [ -z "$COSY_CONTAINER_NAME" ]; then
                COSY_CONTAINER_NAME="$1"
                if [[ "$COSY_CONTAINER_NAME" =~ [[:space:]] ]]; then
                    echo "Error: Invalid container name '$COSY_CONTAINER_NAME' - cannot contain spaces" >&2
                    exit 1
                fi
                if [[ "$COSY_CONTAINER_NAME" =~ [^a-zA-Z0-9_-] ]]; then
                    echo "Error: Invalid container name '$COSY_CONTAINER_NAME'" >&2
                    echo "Container names can only contain: letters, numbers, hyphens, underscores" >&2
                    exit 1
                fi
            else
                EXEC_CMD+=("$1")
            fi
            shift
            continue
        fi

        # Try feature parsers first
        for cap in "${FEATURES[@]}"; do
            if type "feature_${cap}_parse" &>/dev/null 2>&1; then
                PARSE_CONSUMED=0
                # shellcheck disable=SC2086
                if feature_${cap}_parse "$@"; then
                    handled=true
                    break
                fi
            fi
        done

        # If not handled by features, try intercepted parsers
        if ! $handled; then
            for parser in "${INTERCEPTED_PARSERS[@]}"; do
                PARSE_CONSUMED=0
                if $parser "$@"; then
                    handled=true
                    break
                fi
            done
        fi

        if $handled; then
            if [ "$PARSE_CONSUMED" -gt 0 ]; then
                for ((i=0; i<PARSE_CONSUMED; i++)); do
                    shift
                done
            else
                shift
            fi
            continue
        fi

        case "$1" in
            --bootstrap-append-inline)
                CLI_BOOTSTRAP_APPEND_INLINE="$2"
                shift 2
                continue
                ;;
            --bootstrap-append-script)
                # shellcheck disable=SC2034
                CLI_BOOTSTRAP_APPEND_SCRIPT="$2"
                shift 2
                continue
                ;;
            --bootstrap-inline)
                CLI_BOOTSTRAP_INLINE="$2"
                shift 2
                continue
                ;;
            --bootstrap-script)
                CLI_BOOTSTRAP_SCRIPT="$2"
                shift 2
                continue
                ;;
            --cmd)
                CONTAINER_CMD="$2"
                USER_SET_CMD=true
                shift 2
                continue
                ;;
            --debug)
                DEBUG=true
                shift
                continue
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                continue
                ;;
            --entrypoint)
                CONTAINER_ENTRYPOINT="$2"
                shift 2
                continue
                ;;
            --sudo)
                ENABLE_SUDO=true
                shift
                continue
                ;;
            --no-create-groups)
                NO_CREATE_GROUPS=true
                shift
                continue
                ;;
            --help|-h|help)
                # Show context-aware help based on subcommand
                if is_create_subcommand; then
                    show_create_help
                elif is_run_subcommand; then
                    show_run_help
                elif is_recreate_subcommand; then
                    show_recreate_help
                else
                    # Fallback for other subcommands (shouldn't reach here normally)
                    echo "cosy - Container management tool"
                    exit 0
                fi
                ;;
            --image|-i)
                IMAGE="$2"
                shift 2
                continue
                ;;
            --root)
                RUN_AS_ROOT=true
                shift
                continue
                ;;
            --version|-V)
                echo "cosy version $COSY_VERSION"
                exit 0
                ;;
        esac

        if [ -n "$COSY_CONTAINER_NAME" ]; then
            echo "Error: Unknown option '$1' after container name" >&2
            echo "Use '--' to separate container flags from command arguments" >&2
            echo "Example: cosy run container -- command -flag" >&2
            exit 1
        fi

        set +e
        passthrough_add_flag "$@"
        local consumed=$?
        set -e
        for ((i=0; i<consumed; i++)); do
            shift
        done
    done
}

setup_all_features() {
    AUDIO_ARGS=()
    CAPABILITY_ARGS=()
    DBUS_ARGS=()
    DISPLAY_ARGS=()
    GPU_ARGS=()
    HOME_ARGS=()
    INPUT_ARGS=()
    INTERCEPTED_ARGS=()
    NETWORK_ARGS=()
    PODMAN_SOCKET_ARGS=()
    SYSTEMD_ARGS=()
    TMPFS_ARGS=()
    USER_NAMESPACE_ARGS=()

    for cap in "${FEATURES[@]}"; do
        if type "feature_${cap}_setup" &>/dev/null 2>&1; then
            # shellcheck disable=SC2086
            feature_${cap}_setup
        fi
    done

    intercepted_systemd_setup
    intercepted_network_setup
    validate_intercepted_flags

    automatic_setup_all
    passthrough_build_args

    # Validate features after setup to check for access issues
    for cap in "${FEATURES[@]}"; do
        if type "feature_${cap}_validate" &>/dev/null 2>&1; then
            # shellcheck disable=SC2086
            feature_${cap}_validate
        fi
    done
}

# ==============================================================================
# BOOTSTRAP SCRIPT CREATION
# ==============================================================================

# create_bootstrap_script - Generate bootstrap script for container initialization
#
# Outputs:
#   Complete bootstrap script to stdout
#
# Returns:
#   Exits with 1 if script files not found, 0 on success
#
# Notes:
#   Uses CLI_BOOTSTRAP_INLINE, CLI_BOOTSTRAP_SCRIPT, or generates default
#   Default creates user, sets up home directory, configures XDG dirs
#   Supports custom append scripts via CLI_BOOTSTRAP_APPEND_INLINE or CLI_BOOTSTRAP_APPEND
#   Masks D-Bus services when using host D-Bus
create_bootstrap_script() {
    local bootstrap_inline="${CLI_BOOTSTRAP_INLINE:-}"
    local bootstrap_script_source="${CLI_BOOTSTRAP_SCRIPT:-${BOOTSTRAP_SCRIPT_PATH:-}}"
    local bootstrap_append_inline="${CLI_BOOTSTRAP_APPEND_INLINE:-}"
    local bootstrap_append_source="${CLI_BOOTSTRAP_APPEND:-${BOOTSTRAP_APPEND_PATH:-}}"

    if [ -n "$bootstrap_inline" ]; then
        echo "#!/bin/sh"
        echo "set -e"
        echo "$bootstrap_inline"
    elif [ -n "$bootstrap_script_source" ]; then
        if [ -f "$bootstrap_script_source" ]; then
            cat "$bootstrap_script_source"
        else
            echo "Error: Bootstrap script not found: $bootstrap_script_source" >&2
            exit 1
        fi
    else
        # Generate stderr redirect for bootstrap script based on debug mode
        local BS_STDERR=""
        if [ "$DEBUG" != true ]; then
            BS_STDERR="2>/dev/null"
        fi

        cat <<BOOTSTRAP_EOF
#!/bin/sh
set -e

TARGET_USER="\${COSY_CONTAINER_USER}"
TARGET_UID="\${COSY_CONTAINER_UID}"
TARGET_GID="\${COSY_CONTAINER_GID}"
TARGET_HOME="\${COSY_CONTAINER_HOME}"

# Create user if it doesn't exist
if ! getent passwd "\$TARGET_UID" >/dev/null 2>&1; then
    if ! getent group "\$TARGET_GID" >/dev/null 2>&1; then
        groupadd -g "\$TARGET_GID" "\$TARGET_USER" $BS_STDERR || true
    fi

    useradd \\
        -u "\$TARGET_UID" \\
        -g "\$TARGET_GID" \\
        -d "\$TARGET_HOME" \\
        -s /bin/bash \\
        -M \\
        "\$TARGET_USER" $BS_STDERR || true
fi

# Ensure home directory has correct ownership
chown -R "\$TARGET_UID:\$TARGET_GID" "\$TARGET_HOME" $BS_STDERR || true

# Set up XDG_RUNTIME_DIR ownership
# tmpfs is created by podman, but we need to set correct ownership
# Per XDG spec: must be owned by user with mode 0700
chown "\$TARGET_UID:\$TARGET_GID" "/run/user/\$TARGET_UID"
chmod 0700 "/run/user/\$TARGET_UID"

# Fix podman socket directory ownership if it exists
if [ -d "/run/user/\$TARGET_UID/podman" ]; then
    chown "\$TARGET_UID:\$TARGET_GID" "/run/user/\$TARGET_UID/podman"
fi

# Create XDG_STATE_HOME directory
# Per XDG spec: used for logs, history, recent files, session state
mkdir -p "\$TARGET_HOME/.local/state"
chown -R "\$TARGET_UID:\$TARGET_GID" "\$TARGET_HOME/.local"
chmod 0700 "\$TARGET_HOME/.local/state"

# Set hostname persistently (skip if read-only filesystem)
echo "\$COSY_CONTAINER_NAME" > /etc/hostname $BS_STDERR || true
hostname "\$COSY_CONTAINER_NAME" $BS_STDERR || true

# Configure shell prompt for root (red) - skip if read-only filesystem
cat >> /root/.bashrc <<'PROMPT_EOF' $BS_STDERR || true

# Cosy custom prompt
if [ "\$PS1" ]; then
    PS1='\[\033[1;91m\][cosy]\u@\h:\w\$\[\033[0m\] '
fi
PROMPT_EOF

# Configure shell prompt for user (green)
cat >> "\$TARGET_HOME/.bashrc" <<'PROMPT_EOF' $BS_STDERR || true

# Cosy custom prompt
if [ "\$PS1" ]; then
    PS1='\[\033[01;32m\][cosy]\u@\h:\w\$\[\033[0m\] '
fi
PROMPT_EOF
chown "\$TARGET_UID:\$TARGET_GID" "\$TARGET_HOME/.bashrc" $BS_STDERR || true

# Configure passwordless sudo if --sudo flag was used
if [ "\${ENABLE_SUDO:-false}" = "true" ]; then
    if command -v sudo >/dev/null 2>&1; then
        mkdir -p /etc/sudoers.d
        echo "\$TARGET_USER ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/cosy-user
        chmod 0440 /etc/sudoers.d/cosy-user
    fi
fi

# Create supplementary groups for better UX when using device access features
# Note: --group-add keep-groups already preserves group membership for actual permissions.
# The kernel checks the real GID values in the process credentials for device access,
# which works even when groups show as "nobody" (65534) due to unmapped GIDs.
# We create these groups here purely to improve the user experience - so "id" and "ls -l"
# show meaningful group names instead of "nobody". This is cosmetic only.
#
# This behavior can be disabled with the --no-create-groups flag.
# We only create groups if the GID is not already in use to avoid conflicts.
# If creation fails (GID conflict, read-only /etc, etc.), we silently continue.

if [ "\${NO_CREATE_GROUPS:-false}" != "true" ]; then
    # Video group (for --gpu flag, /dev/dri devices)
    if [ -n "\${HOST_VIDEO_GID:-}" ]; then
        # Only create if neither the GID nor the group name is already in use
        if ! getent group "\$HOST_VIDEO_GID" >/dev/null 2>&1; then
            if ! getent group video >/dev/null 2>&1; then
                groupadd -g "\$HOST_VIDEO_GID" video $BS_STDERR || true
            fi
        fi
    fi

    # Render group (for --gpu flag, /dev/dri/renderD* devices)
    if [ -n "\${HOST_RENDER_GID:-}" ]; then
        # Only create if neither the GID nor the group name is already in use
        if ! getent group "\$HOST_RENDER_GID" >/dev/null 2>&1; then
            if ! getent group render >/dev/null 2>&1; then
                groupadd -g "\$HOST_RENDER_GID" render $BS_STDERR || true
            fi
        fi
    fi

    # Input group (for --input flag, /dev/input devices)
    if [ -n "\${HOST_INPUT_GID:-}" ]; then
        # Only create if neither the GID nor the group name is already in use
        if ! getent group "\$HOST_INPUT_GID" >/dev/null 2>&1; then
            if ! getent group input >/dev/null 2>&1; then
                groupadd -g "\$HOST_INPUT_GID" input $BS_STDERR || true
            fi
        fi
    fi
fi
BOOTSTRAP_EOF
    fi

    # When using host D-Bus, mask container's D-Bus services to prevent conflicts and delays
    # Use symlinks to /dev/null instead of systemctl mask to work without systemd running
    if [ "$ENABLE_DBUS" = true ] || [ "$ENABLE_DBUS_SYSTEM" = true ]; then
        echo ""
        echo "# Mask D-Bus services (using host D-Bus via --dbus or --dbus-system flag)"
        echo "mkdir -p /etc/systemd/system"
        echo "ln -sf /dev/null /etc/systemd/system/dbus-broker.service"
        echo "ln -sf /dev/null /etc/systemd/system/dbus.socket"
        echo "ln -sf /dev/null /etc/systemd/system/dbus.service"
    fi

    # Append custom script if specified
    if [ -n "$bootstrap_append_inline" ]; then
        echo ""
        echo "# Custom append (inline)"
        echo "$bootstrap_append_inline"
    elif [ -n "$bootstrap_append_source" ]; then
        if [ -f "$bootstrap_append_source" ]; then
            echo ""
            echo "# Custom append script"
            cat "$bootstrap_append_source"
        else
            echo "Error: Bootstrap append script not found: $bootstrap_append_source" >&2
            exit 1
        fi
    fi
}

# ==============================================================================
# CONTAINER OPERATIONS
# ==============================================================================

# Execute command with dry-run and debug support
execute_command() {
    if [ "${DEBUG:-false}" = true ] || [ "${DRY_RUN:-false}" = true ]; then
        echo "[DRY-RUN] $*" >&2
    fi

    if [ "${DRY_RUN:-false}" != true ]; then
        "$@"
    fi
}

create_container_home_directory() {
    if [ ! -d "$APP_HOME" ]; then
        mkdir -p "$APP_HOME"
        log "Created container home directory: $APP_HOME"
    fi
}

# Build container create flags as a string
# Used by recreate command to build containers programmatically
build_container_create_flags() {
    local container_name="$1"
    local image="${2:-$IMAGE}"
    local cmd="${3:-sleep infinity}"
    local hostname="${4:-$container_name}"

    local flags=(
        --name "$container_name"
        --hostname "$hostname"
    )

    flags+=("${A11Y_ARGS[@]}")
    flags+=("${AUDIO_ARGS[@]}")
    flags+=("${DBUS_ARGS[@]}")
    flags+=("${DISPLAY_ARGS[@]}")
    flags+=("${GPU_ARGS[@]}")
    flags+=("${HOME_ARGS[@]}")
    flags+=("${INPUT_ARGS[@]}")
    flags+=("${INTERCEPTED_ARGS[@]}")
    flags+=("${LABEL_ARGS[@]}")
    flags+=("${NETWORK_ARGS[@]}")
    flags+=("${PASSTHROUGH_ARGS[@]}")
    flags+=("${PODMAN_SOCKET_ARGS[@]}")
    flags+=("${SYSTEMD_ARGS[@]}")
    flags+=("${TMPFS_ARGS[@]}")
    flags+=("${USER_NAMESPACE_ARGS[@]}")

    if [ -n "${CONTAINER_ENTRYPOINT:-}" ]; then
        flags+=(--entrypoint "$CONTAINER_ENTRYPOINT")
    fi

    flags+=("${image:-$DEFAULT_IMAGE}")
    # Don't quote $cmd to allow word splitting (e.g., "sleep infinity" -> sleep, infinity)
    # shellcheck disable=SC2206
    flags+=($cmd)

    # Use %s instead of %q since flags will be expanded unquoted later
    printf '%s ' "${flags[@]}"
}

# run_podman_create - Create and start container with configured features
#
# Returns:
#   Exits with 1 on error, 0 on success
#
# Notes:
#   Creates home directory if not in dry-run mode
#   Executes podman create with all configured feature arguments
#   Waits for container to reach running state with timeout
#   Executes bootstrap script after container starts
#   Respects DRY_RUN and DEBUG environment variables
run_podman_create() {
    if [ "${DRY_RUN:-false}" != true ]; then
        create_container_home_directory
    fi

    local ENTRYPOINT_ARGS=()
    if [ -n "${CONTAINER_ENTRYPOINT:-}" ]; then
        ENTRYPOINT_ARGS=(--entrypoint "$CONTAINER_ENTRYPOINT")
    fi

    if [ "${DRY_RUN:-false}" = true ]; then
        echo "=== DRY RUN MODE - No changes will be made ===" >&2
        echo "" >&2
    fi

    # Print or execute podman create command
    if [ "${DRY_RUN:-false}" = true ] || [ "${DEBUG:-false}" = true ]; then
        # Note: CONTAINER_CMD is intentionally expanded unquoted to support multi-argument
        # shellcheck disable=SC2086
        echo "podman create \\"
        echo "    --name \"$COSY_CONTAINER_NAME\" \\"
        echo "    --hostname \"$COSY_CONTAINER_NAME\" \\"
        for arg in "${A11Y_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${AUDIO_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${CAPABILITY_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${DBUS_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${DISPLAY_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${GPU_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${HOME_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${INPUT_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${INTERCEPTED_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${LABEL_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${NETWORK_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${PASSTHROUGH_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${PODMAN_SOCKET_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${SYSTEMD_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${TMPFS_ARGS[@]}"; do echo "    $arg \\"; done
        for arg in "${USER_NAMESPACE_ARGS[@]}"; do echo "    $arg \\"; done
        if [ ${#ENTRYPOINT_ARGS[@]} -gt 0 ]; then
            echo "    --entrypoint \"${CONTAINER_ENTRYPOINT}\" \\"
        fi
        echo "    \"${IMAGE:-$DEFAULT_IMAGE}\" \\"
        echo "    ${CONTAINER_CMD:-sleep infinity}"
    fi

    if [ "${DRY_RUN:-false}" != true ]; then
        COMMAND_HISTORY_IMAGE="${IMAGE:-$DEFAULT_IMAGE}"
        COMMAND_HISTORY_FEATURES=$(build_features_json)

        # Note: CONTAINER_CMD is intentionally expanded unquoted to support multi-argument
        # commands (e.g., "sleep infinity" becomes two separate arguments: sleep and infinity).
        # shellcheck disable=SC2086
        podman create \
            --name "$COSY_CONTAINER_NAME" \
            --hostname "$COSY_CONTAINER_NAME" \
            "${A11Y_ARGS[@]}" \
            "${AUDIO_ARGS[@]}" \
            "${CAPABILITY_ARGS[@]}" \
            "${DBUS_ARGS[@]}" \
            "${DISPLAY_ARGS[@]}" \
            "${ENTRYPOINT_ARGS[@]}" \
            "${GPU_ARGS[@]}" \
            "${HOME_ARGS[@]}" \
            "${INPUT_ARGS[@]}" \
            "${INTERCEPTED_ARGS[@]}" \
            "${LABEL_ARGS[@]}" \
            "${NETWORK_ARGS[@]}" \
            "${PASSTHROUGH_ARGS[@]}" \
            "${PODMAN_SOCKET_ARGS[@]}" \
            "${SYSTEMD_ARGS[@]}" \
            "${TMPFS_ARGS[@]}" \
            "${USER_NAMESPACE_ARGS[@]}" \
            "${IMAGE:-$DEFAULT_IMAGE}" \
            ${CONTAINER_CMD:-sleep infinity} >/dev/null

        local image_hash=$(command podman inspect --format '{{.Image}}' "$COSY_CONTAINER_NAME" 2>/dev/null || echo "")
        if [ -n "$image_hash" ]; then
            COMMAND_HISTORY_IMAGE_ID="sha256:$image_hash"
        else
            COMMAND_HISTORY_IMAGE_ID=""
        fi
    fi

    if [ "${DRY_RUN:-false}" = true ] || [ "${DEBUG:-false}" = true ]; then
        echo "podman start \"$COSY_CONTAINER_NAME\""
    fi

    if [ "${DRY_RUN:-false}" != true ]; then
        podman start "$COSY_CONTAINER_NAME" >/dev/null
        wait_for_container_running "$COSY_CONTAINER_NAME" || exit 1
    fi

    # Execute bootstrap script
    BOOTSTRAP_SCRIPT=$(create_bootstrap_script)
    if [ "${DRY_RUN:-false}" = true ] || [ "${DEBUG:-false}" = true ]; then
        echo "podman exec --user root \"$COSY_CONTAINER_NAME\" /bin/sh -c '<bootstrap script>'"
    fi

    if [ "${DRY_RUN:-false}" != true ]; then
        podman exec \
            -e COSY_CONTAINER_GID="$HOST_GID" \
            -e COSY_CONTAINER_HOME="/home/$HOST_USER" \
            -e COSY_CONTAINER_UID="$HOST_UID" \
            -e COSY_CONTAINER_USER="$HOST_USER" \
            -e ENABLE_SUDO="$ENABLE_SUDO" \
            --user root \
            "$COSY_CONTAINER_NAME" \
            /bin/sh -c "$BOOTSTRAP_SCRIPT"
    fi
}

exec_as_user() {
    if [ "${DRY_RUN:-false}" = true ] || [ "${DEBUG:-false}" = true ]; then
        echo "podman exec --user root \"$COSY_CONTAINER_NAME\" /bin/sh -c '<setup /run/user/$HOST_UID>'"
        echo "podman exec -it -w \"/home/$HOST_USER\" --user \"$HOST_UID:$HOST_GID\" \"$COSY_CONTAINER_NAME\" ${EXEC_CMD[*]}"
    fi

    if [ "${DRY_RUN:-false}" = true ]; then
        return 0
    fi

    # Ensure /run/user/$HOST_UID exists with correct ownership
    podman exec --user root "$COSY_CONTAINER_NAME" /bin/sh -c "
        mkdir -p /run/user/$HOST_UID
        chown $HOST_UID:$HOST_GID /run/user/$HOST_UID
        chmod 0700 /run/user/$HOST_UID
    " 2>/dev/null || true

    podman exec -it \
        -e DISPLAY="${DISPLAY:-}" \
        -e PULSE_SERVER="${PULSE_SERVER:-}" \
        -e WAYLAND_DISPLAY="${WAYLAND_DISPLAY:-}" \
        -w "/home/$HOST_USER" \
        --user "$HOST_UID:$HOST_GID" \
        "$COSY_CONTAINER_NAME" \
        "${EXEC_CMD[@]}"
}

exec_as_root() {
    local interactive="${1:-false}"

    # Determine exec flags based on whether this is interactive
    local exec_flags=()
    if [ "$interactive" = "true" ]; then
        exec_flags=(-it)
    fi

    if [ "${DRY_RUN:-false}" = true ] || [ "${DEBUG:-false}" = true ]; then
        echo "podman exec ${exec_flags[*]} -w \"/root\" --user root \"$COSY_CONTAINER_NAME\" ${EXEC_CMD[*]}"
    fi

    if [ "${DRY_RUN:-false}" = true ]; then
        return 0
    fi

    podman exec \
        "${exec_flags[@]}" \
        -e HOME=/root \
        -w "/root" \
        --user root \
        "$COSY_CONTAINER_NAME" \
        "${EXEC_CMD[@]}"
}

# ==============================================================================
# SUBCOMMAND HANDLERS
# ==============================================================================

# Subcommand detection helpers
is_create_subcommand() {
    [ "$SUBCOMMAND" = "create" ]
}

is_enter_subcommand() {
    [ "$SUBCOMMAND" = "enter" ]
}

is_run_subcommand() {
    [ "$SUBCOMMAND" = "run" ]
}

is_container_subcommand() {
    is_create_subcommand || is_enter_subcommand || is_run_subcommand
}

# Initialize all variables needed for container operations
init_container_vars() {

    ENABLE_A11Y="${COSY_A11Y_DEFAULT:-false}"
    ENABLE_AUDIO="${COSY_AUDIO_DEFAULT}"
    ENABLE_DBUS="${COSY_DBUS_DEFAULT}"
    ENABLE_DBUS_SYSTEM="${COSY_DBUS_SYSTEM_DEFAULT}"
    ENABLE_DISPLAY="${COSY_DISPLAY_DEFAULT}"
    ENABLE_GPU="${COSY_GPU_DEFAULT}"
    ENABLE_INPUT="${COSY_INPUT_DEFAULT}"
    ENABLE_PODMAN="${COSY_PODMAN_DEFAULT}"

    HOST_GID=$(id -g)
    HOST_UID=$(id -u)
    HOST_USER=$(id -un)
    XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$HOST_UID}"

    # Network variables - initialize based on default
    case "${COSY_NETWORK_DEFAULT}" in
        none)
            DISABLE_NETWORK=true
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK=""
            ;;
        host)
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=true
            CUSTOM_NETWORK=""
            ;;
        default)
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK=""
            ;;
        *)
            # Custom network
            DISABLE_NETWORK=false
            ENABLE_HOST_NETWORK=false
            CUSTOM_NETWORK="${COSY_NETWORK_DEFAULT}"
            ;;
    esac

    # Systemd variables
    SYSTEMD_MODE="${COSY_SYSTEMD_DEFAULT}"
    SYSTEMD_EXPLICITLY_SET=false

    # Security variables
    DEVICES=()
    EXTRA_MOUNTS=()
    SECURITY_OPTS=()
    USER_TMPFS=()
    USER_LABELS=()
    USER_ENV_VARS=()

    # Sudo configuration
    ENABLE_SUDO="${COSY_SUDO_DEFAULT}"

    # Label args - mark as cosy-managed
    LABEL_ARGS=(--label "cosy.managed=true")

    # Image and command
    CONTAINER_CMD="${COSY_CMD_DEFAULT}"
    CONTAINER_ENTRYPOINT="${COSY_ENTRYPOINT_DEFAULT}"
    COSY_CONTAINER_NAME=""
    EXEC_CMD=()
    IMAGE="${COSY_IMAGE:-$DEFAULT_IMAGE}"

    # Execution mode
    RUN_AS_ROOT=false

    # Clear inspect cache
    clear_inspect_cache
}

# ==============================================================================
# HELP FUNCTIONS
# ==============================================================================

show_create_help() {
    cat <<'EOF'
Usage: cosy create [OPTIONS] CONTAINER_NAME

Create a new container with specified features without entering it.

Options:
  --a11y                        Enable accessibility bus (AT-SPI)
  --audio                       Enable audio support (/dev/snd + PipeWire/PulseAudio sockets) (/dev/snd + PipeWire/PulseAudio sockets)
  --bootstrap-append-inline CMD Append inline command to built-in bootstrap
  --bootstrap-append-script PATH Append script file to built-in bootstrap
  --bootstrap-inline CMD        Replace built-in bootstrap with inline command
  --bootstrap-script PATH       Replace built-in bootstrap with script file
  --cmd COMMAND                 Container default command
  --dbus                        Enable D-Bus session bus
  --dbus-system                 Enable D-Bus system bus
  --device DEVICE               Mount device into container (repeatable)
  --entrypoint PATH             Override container entrypoint
  --gpu                         Enable GPU access via /dev/dri
  --sudo                        Enable passwordless sudo access
  --help, -h                    Show this help message
  --image IMAGE, -i IMAGE       Base container image (default: $COSY_DEFAULT_IMAGE)
  --input                       Enable input device access (joysticks, gamepads, etc.)
  --network MODE                Network mode: default, none, or host
  --no-create-groups            Disable automatic group creation in container
  --no-display                  Disable display forwarding (enabled by default)
  --podman                      Enable Podman socket access
  --read-only                   Mount container root filesystem as read-only
  --security-opt OPTION         Security options (repeatable)
  --systemd MODE                Systemd mode: true (auto), false, or always
  --tmpfs PATH                  Mount tmpfs at path (repeatable)
  -v, --volume SRC:DST[:OPTS]   Add volume mount (repeatable)

Examples:
  cosy create mybox
  cosy create --gpu --audio photo-editor
  cosy create --network none --read-only secure-app
  cosy create --image ubuntu:22.04 devbox

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_run_help() {
    cat <<'EOF'
Usage: cosy run [OPTIONS] CONTAINER_NAME COMMAND [ARGS...]

Run a command in a container, creating it if it doesn't exist.

Options:
  --a11y                        Enable accessibility bus (AT-SPI)
  --audio                       Enable audio support (/dev/snd + PipeWire/PulseAudio sockets) (/dev/snd + PipeWire/PulseAudio sockets)
  --dbus                        Enable D-Bus session bus
  --dbus-system                 Enable D-Bus system bus
  --device DEVICE               Mount device into container (repeatable)
  --gpu                         Enable GPU access via /dev/dri
  --help, -h                    Show this help message
  --image IMAGE, -i IMAGE       Base container image (default: $COSY_DEFAULT_IMAGE)
  --input                       Enable input device access (joysticks, gamepads, etc.)
  --network MODE                Network mode: default, none, or host
  --no-create-groups            Disable automatic group creation in container
  --no-display                  Disable display forwarding (enabled by default)
  --podman                      Enable Podman socket access
  --root                        Execute command as root user
  --security-opt OPTION         Security options (repeatable)
  --systemd MODE                Systemd mode: true (auto), false, or always
  --tmpfs PATH                  Mount tmpfs at path (repeatable)
  -v, --volume SRC:DST[:OPTS]   Add volume mount (repeatable)

Examples:
  cosy run mybox bash
  cosy run --gpu mybox python script.py
  cosy run --root mybox dnf install -y vim
  cosy run mybox -- grep -r "pattern" /path

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_enter_help() {
    cat <<'EOF'
Usage: cosy enter [OPTIONS] CONTAINER_NAME [COMMAND...]

Enter an existing container interactively, creating it if it doesn't exist.

Options:
  --root                        Execute as root user
  --help, -h                    Show this help message

Examples:
  cosy enter mybox
  cosy enter mybox zsh
  cosy enter --root mybox

Notes:
  - If no command is specified, defaults to bash
  - Container must already exist (use 'cosy create' first to set features)
  - Starts the container if it's stopped

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_clone_help() {
    cat <<'EOF'
Usage: cosy clone [OPTIONS] SOURCE_CONTAINER DEST_CONTAINER

Clone a container with different features, preserving installed packages.

Options:
  --a11y                        Enable accessibility bus
  --audio                       Enable audio support (/dev/snd + PipeWire/PulseAudio sockets)
  --dbus                        Enable D-Bus session bus
  --dbus-system                 Enable D-Bus system bus
  --device DEVICE               Mount device into container (repeatable)
  --gpu                         Enable GPU access
  --help, -h                    Show this help message
  --input                       Enable input device access
  --network MODE                Network mode: default, none, or host
  --no-display                  Disable display forwarding
  --podman                      Enable Podman socket access
  --security-opt OPTION         Security options (repeatable)
  --show-diff                   Preview changes without executing
  --systemd MODE                Systemd mode: true, false, or always
  --tmpfs PATH                  Mount tmpfs at path (repeatable)
  --yes, -y                     Skip confirmation prompt
  -v, --volume SRC:DST[:OPTS]   Add volume mount (repeatable)

Examples:
  cosy clone mybox mybox-v2
  cosy clone --audio --gpu photo-editor photo-editor-v2
  cosy clone --show-diff --network none mybox secure-box
  cosy clone --yes --dbus dev-env dev-env-test

What Gets Preserved:
  - Writable layer (installed packages, system modifications)
  - Home directory (copied to new location)

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_recreate_help() {
    cat <<'EOF'
Usage: cosy recreate [OPTIONS] CONTAINER_NAME

Recreate a container in place with new features, preserving installed packages.

Options:
  --a11y                        Enable accessibility bus
  --audio                       Enable audio support (/dev/snd + PipeWire/PulseAudio sockets)
  --dbus                        Enable D-Bus session bus
  --dbus-system                 Enable D-Bus system bus
  --device DEVICE               Mount device into container (repeatable)
  --gpu                         Enable GPU access
  --help, -h                    Show this help message
  --input                       Enable input device access
  --network MODE                Network mode: default, none, or host
  --no-display                  Disable display forwarding
  --podman                      Enable Podman socket access
  --security-opt OPTION         Security options (repeatable)
  --show-diff                   Preview changes without executing
  --systemd MODE                Systemd mode: true, false, or always
  --tmpfs PATH                  Mount tmpfs at path (repeatable)
  --yes, -y                     Skip confirmation prompt
  -v, --volume SRC:DST[:OPTS]   Add volume mount (repeatable)

Examples:
  cosy recreate --audio photo-editor
  cosy recreate --network none --gpu dev-container
  cosy recreate --show-diff --dbus mybox
  cosy recreate --yes --audio --gpu media-app

What Gets Preserved:
  - Writable layer (installed packages, system modifications)
  - Home directory (stays in same location)
  - Container name (same name)

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_inspect_help() {
    cat <<'EOF'
Usage: cosy inspect [OPTIONS] CONTAINER_NAME

Display container configuration and features.

Options:
  --format=FORMAT               Output format: human (default) or cli
  --help, -h                    Show this help message

Formats:
  human                         Human-readable output showing all features
  cli                           Shows equivalent CLI flags to recreate container

Examples:
  cosy inspect myapp
  cosy inspect --format=cli myapp
  cosy inspect --format=human photo-editor

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_list_help() {
    cat <<'EOF'
Usage: cosy list
       cosy ls

List all cosy-managed containers with their status and features.

Options:
  --help, -h                    Show this help message

Examples:
  cosy list
  cosy ls

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_rm_help() {
    cat <<'EOF'
Usage: cosy rm [OPTIONS] CONTAINER_NAME [CONTAINER_NAME...]

Remove one or more containers.

Options:
  --home                        Also remove container home directories
  --help, -h                    Show this help message

Examples:
  cosy rm old-container
  cosy rm --home old-container
  cosy rm container1 container2 container3

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

show_stop_help() {
    cat <<'EOF'
Usage: cosy stop CONTAINER_NAME

Stop a running container.

Options:
  --help, -h                    Show this help message

Examples:
  cosy stop myapp
  cosy stop photo-editor

For more information: https://github.com/BenSmith/cosy
EOF
    exit 0
}

# handle_create - Create new container without starting interactive session
#
# Args:
#   $@ - container options and name
#
# Returns:
#   Exits with 1 on error, 0 on success
#
# Notes:
#   Creates container with all specified features and options
#   Stores original create command in container label
#   Generates new session ID for command history tracking
#   Exits with error if container already exists
handle_create() {
    parse_container_args "$@"

    require_container_name "$COSY_CONTAINER_NAME" "Usage: cosy create [OPTIONS] COSY_CONTAINER_NAME"

    require_container_not_exists "$COSY_CONTAINER_NAME"

    apply_image_command_if_default

    COMMAND_HISTORY_SESSION_ID=$(generate_session_id)
    LABEL_ARGS+=(--label "cosy.session_id=$COMMAND_HISTORY_SESSION_ID")

    # Build and store the original create command
    local create_cmd="cosy"
    for arg in "${ORIGINAL_COMMAND_ARGS[@]}"; do
        create_cmd+=" $(printf %q "$arg")"
    done
    LABEL_ARGS+=(--label "cosy.create-command=$create_cmd")

    setup_all_features
    run_podman_create

    echo "Container created successfully: $COSY_CONTAINER_NAME"
}

# handle_run - Create or start container and run non-interactive command
#
# Args:
#   $@ - container options, name, and command to run
#
# Returns:
#   Exits with 1 on error, otherwise exits with command exit code
#
# Notes:
#   Creates container if it doesn't exist, otherwise reuses existing
#   Starts container if stopped
#   Executes specified command non-interactively
#   Requires command to be specified (no default)
handle_run() {
    parse_container_args "$@"

    require_container_name "$COSY_CONTAINER_NAME" "Usage: cosy run [OPTIONS] COSY_CONTAINER_NAME [COMMAND...]"

    apply_image_command_if_default

    if [ "${DRY_RUN:-false}" = true ]; then
        COMMAND_HISTORY_SESSION_ID=$(generate_session_id)
        LABEL_ARGS+=(--label "cosy.session_id=$COMMAND_HISTORY_SESSION_ID")
        setup_all_features
        run_podman_create
    else
        if ! container_exists "$COSY_CONTAINER_NAME"; then
            COMMAND_HISTORY_SESSION_ID=$(generate_session_id)
            LABEL_ARGS+=(--label "cosy.session_id=$COMMAND_HISTORY_SESSION_ID")
            setup_all_features
            run_podman_create
        else
            COMMAND_HISTORY_SESSION_ID=$(get_or_create_session_id "$COSY_CONTAINER_NAME")
            if ! podman ps --filter "name=^${COSY_CONTAINER_NAME}$" --format "{{.Names}}" | grep -q "^${COSY_CONTAINER_NAME}$"; then
                podman start "$COSY_CONTAINER_NAME" >/dev/null
                wait_for_container_running "$COSY_CONTAINER_NAME" || exit 1
            fi
        fi
    fi

    if [ ${#EXEC_CMD[@]} -eq 0 ]; then
        echo "Error: No command specified for 'run'" >&2
        echo "Usage: cosy run [OPTIONS] COSY_CONTAINER_NAME COMMAND [ARGS...]" >&2
        exit 1
    fi

    if [ "$RUN_AS_ROOT" = true ]; then
        exec_as_root false  # false = non-interactive
    else
        exec_as_user
    fi
}

# handle_enter - Enter existing container with interactive shell
#
# Args:
#   $@ - optional --root flag, container name, and optional command
#
# Returns:
#   Exits with 1 on error, otherwise exits with command exit code
#
# Notes:
#   Container must already exist
#   Starts container if stopped
#   Defaults to bash if no command specified
#   Supports --root flag to run as root user
handle_enter() {
    init_container_vars

    # Parse --root flag if present
    while [[ $# -gt 0 ]] && [[ "$1" == --* ]]; do
        case "$1" in
            --help|-h)
                show_enter_help
                ;;
            --root)
                RUN_AS_ROOT=true
                shift
                ;;
            *)
                echo "Error: Unknown option '$1' for enter command" >&2
                echo "Usage: cosy enter [--root] COSY_CONTAINER_NAME [COMMAND...]" >&2
                exit 1
                ;;
        esac
    done

    require_container_name "${1:-}" "Usage: cosy enter [--root] COSY_CONTAINER_NAME [COMMAND...]"

    COSY_CONTAINER_NAME="$1"
    shift

    # Get existing session ID
    COMMAND_HISTORY_SESSION_ID=$(get_or_create_session_id "$COSY_CONTAINER_NAME")

    EXEC_CMD=("$@")
    if [ ${#EXEC_CMD[@]} -eq 0 ]; then
        EXEC_CMD=("bash")
    fi

    if [ "${DRY_RUN:-false}" != true ]; then
        require_container_exists "$COSY_CONTAINER_NAME"

        if ! podman ps --filter "name=^${COSY_CONTAINER_NAME}$" --format "{{.Names}}" | grep -q "^${COSY_CONTAINER_NAME}$"; then
            podman start "$COSY_CONTAINER_NAME" >/dev/null
            wait_for_container_running "$COSY_CONTAINER_NAME" || exit 1
        fi
    fi

    if [ "$RUN_AS_ROOT" = true ]; then
        exec_as_root true  # true = interactive
    else
        exec_as_user
    fi
}

# handle_list - List all cosy-managed containers and orphaned homes
#
# Returns:
#   0 always
#
# Outputs:
#   Formatted table of containers with status, image, and features
#
# Notes:
#   Shows containers with homes in current COSY_CONTAINER_HOMES_DIR
#   Also displays orphaned home directories without containers
#   Features displayed include: gpu, input, systemd, audio, display, network mode
handle_list() {
    # Check for --help/-h flag
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        show_list_help
    fi

    echo "cosy containers:"

    local containers
    containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null || true)

    # Get all home directories
    local home_dirs
    home_dirs=$(list_home_directories)

    # Build set of home directory names for filtering
    declare -A has_home
    if [ -n "$home_dirs" ]; then
        while IFS= read -r home_name; do
            [ -z "$home_name" ] && continue
            has_home["$home_name"]=1
        done <<< "$home_dirs"
    fi

    # Build list of all names (containers + orphaned homes)
    local all_names=()
    declare -A container_exists

    # Add containers to tracking (only if they have a home in current COSY_CONTAINER_HOMES_DIR)
    if [ -n "$containers" ]; then
        while IFS= read -r container; do
            [ -z "$container" ] && continue
            # Only include containers that have a home directory in current COSY_CONTAINER_HOMES_DIR
            if [ -n "${has_home[$container]:-}" ]; then
                all_names+=("$container")
                container_exists["$container"]=1
            fi
        done <<< "$containers"
    fi

    # Add orphaned homes (homes without containers)
    if [ -n "$home_dirs" ]; then
        while IFS= read -r home_name; do
            [ -z "$home_name" ] && continue
            if [ -z "${container_exists[$home_name]:-}" ]; then
                all_names+=("$home_name")
            fi
        done <<< "$home_dirs"
    fi

    if [ ${#all_names[@]} -eq 0 ]; then
        echo "No cosy containers or home directories found"
        return 0
    fi

    printf "%-30s %-15s %-20s %s\n" "NAME" "STATUS" "IMAGE" "FEATURES"

    for name in "${all_names[@]}"; do
        # Check if this is an actual container or just an orphaned home
        if [ -n "${container_exists[$name]:-}" ]; then
            # This is a container - show full details
            # Cache the inspect data once for this container
            cache_container_inspect "$name" >/dev/null 2>&1 || continue

            local status
            status=$(podman ps -a --filter "name=^${name}$" --format "{{.Status}}" 2>/dev/null | head -1)

            local image
            image=$(get_cached_config "$name" "{{.Config.Image}}" | cut -d: -f1 | rev | cut -d/ -f1 | rev)

            local caps=()

            if [ "$(get_cached_label "$name" "cosy.gpu")" = "true" ]; then
                caps+=("gpu")
            fi

            if [ "$(get_cached_label "$name" "cosy.input")" = "true" ]; then
                caps+=("input")
            fi

            local systemd_label
            systemd_label=$(get_cached_label "$name" "cosy.systemd")
            if [ -n "$systemd_label" ] && [ "$systemd_label" != "false" ] && [ "$systemd_label" != "<no value>" ]; then
                caps+=("systemd")
            fi

            if [ "$(get_cached_label "$name" "cosy.audio")" = "true" ]; then
                caps+=("audio")
            fi

            if [ "$(get_cached_label "$name" "cosy.display")" = "true" ]; then
                caps+=("display")
            fi

            # Detect network mode
            local network_mode
            network_mode=$(get_cached_config "$name" "{{.HostConfig.NetworkMode}}")
            if [ -z "$network_mode" ] || [ "$network_mode" = "<no value>" ]; then
                network_mode="default"
            fi
            case "$network_mode" in
                slirp4netns|pasta|bridge) network_mode="default" ;;
            esac
            if [ "$network_mode" = "host" ]; then
                caps+=("host-net")
            elif [ "$network_mode" = "none" ]; then
                caps+=("no-net")
            fi

            local caps_str
            if [ ${#caps[@]} -gt 0 ]; then
                caps_str=$(IFS=,; echo "${caps[*]}")
            else
                caps_str="-"
            fi

            printf "%-30s %-15s %-20s %s\n" "$name" "$status" "$image" "$caps_str"
        else
            # This is an orphaned home directory (no container)
            printf "%-30s %-15s %-20s %s\n" "$name" "(no container)" "-" "home-only"
        fi
    done
}

# handle_rm - Remove one or more containers
#
# Args:
#   $@ - optional --home flag and container name(s)
#
# Returns:
#   Exits with 1 on error, 0 on success
#
# Notes:
#   Removes container forcefully with immediate stop
#   With --home flag, also removes home directory and desktop entry
#   Accepts multiple container names for batch removal
#   Continues on error for batch operations
handle_rm() {
    require_container_name "${1:-}" "Usage: cosy rm [--home] COSY_CONTAINER_NAME [COSY_CONTAINER_NAME...]"

    local remove_home=false
    local container_names=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_rm_help
                ;;
            --home)
                remove_home=true
                shift
                ;;
            *)
                container_names+=("$1")
                shift
                ;;
        esac
    done

    if [ ${#container_names[@]} -eq 0 ]; then
        echo "Error: Container name required" >&2
        exit 1
    fi

    for container_name in "${container_names[@]}"; do
        if container_exists "$container_name"; then
            echo "Removing container: $container_name"
            podman rm -f --time 0 "$container_name" 2>/dev/null || true
        else
            echo "Container '$container_name' does not exist"
        fi

        if [ "$remove_home" = true ]; then
            # Check for desktop entry and remove it first
            if desktop_entry_exists "$container_name"; then
                local desktop_file
                desktop_file=$(get_desktop_file_path "$container_name")
                rm -f "$desktop_file" 2>/dev/null || true
                echo "Removed desktop entry: $desktop_file"
            fi

            local home_dir="${COSY_CONTAINER_HOMES_DIR}/${container_name}"
            if [ -d "$home_dir" ]; then
                rm -rf "$home_dir"
                echo "Removed home directory: $home_dir"
            fi
        fi
    done
}

# handle_stop - Stop a running container
#
# Args:
#   $1 - container name
#
# Returns:
#   Exits with 1 on error, 0 on success
#
# Notes:
#   Silently ignores errors (container already stopped, etc.)
handle_stop() {
    # Check for --help/-h flag
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        show_stop_help
    fi

    require_container_name "${1:-}" "Usage: cosy stop COSY_CONTAINER_NAME"

    podman stop "$1" 2>/dev/null || true
    echo "Stopped container: $1"
}

# handle_inspect - Display container configuration and features
#
# Args:
#   $@ - optional --format flag and container name
#
# Returns:
#   Exits with 1 on error, 0 on success
#
# Outputs:
#   Container configuration in human or cli format
#
# Notes:
#   Supports --format=human (default) or --format=cli
#   Human format shows feature status, cli format shows recreation command
#   Detects features from container labels and configuration
handle_inspect() {
    local format="human"
    local container_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_inspect_help
                ;;
            --format=*)
                format="${1#*=}"
                shift
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            *)
                container_name="$1"
                shift
                ;;
        esac
    done

    require_container_name "$container_name" "Usage: cosy inspect [--format=FORMAT] COSY_CONTAINER_NAME"

    require_container_exists "$container_name"

    if [ "$format" != "human" ] && [ "$format" != "cli" ]; then
        echo "Error: Invalid format '$format'" >&2
        echo "Valid formats: human, cli" >&2
        exit 1
    fi

    # Detect all features from the existing container
    detect_container_features "$container_name"

    local image
    image=$(podman inspect --format '{{.Config.Image}}' "$container_name" 2>/dev/null)

    if [ "$format" = "human" ]; then
        echo "Container: $container_name"
        echo "Base image: $image"
        echo ""
        echo "Accessibility bus: $([ "${ENABLE_A11Y:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "Audio: $([ "${ENABLE_AUDIO:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "D-Bus session: $([ "${ENABLE_DBUS:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "D-Bus system: $([ "${ENABLE_DBUS_SYSTEM:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "Display: $([ "${ENABLE_DISPLAY:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "GPU: $([ "${ENABLE_GPU:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "Input devices: $([ "${ENABLE_INPUT:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "Network mode: ${NETWORK_MODE:=default}"
        echo "Podman socket: $([ "${ENABLE_PODMAN:-false}" = true ] && echo "enabled" || echo "disabled")"
        echo "Systemd: ${SYSTEMD_MODE:=false}"

        if [ "${#USER_TMPFS[@]}" -gt 0 ] 2>/dev/null; then
            echo "Tmpfs mounts:"
            for tmpfs in "${USER_TMPFS[@]}"; do
                local tmpfs_path="${tmpfs%%:*}"
                echo "  - $tmpfs_path"
            done
        fi

        if [ "${#DEVICES[@]}" -gt 0 ] 2>/dev/null; then
            echo "Devices: ${DEVICES[*]}"
        fi
        if [ "${#EXTRA_MOUNTS[@]}" -gt 0 ] 2>/dev/null; then
            for mount in "${EXTRA_MOUNTS[@]}"; do
                echo "$mount"
            done
        fi

        # Show original create command if available
        local create_cmd
        create_cmd=$(podman inspect --format '{{index .Config.Labels "cosy.create-command"}}' "$container_name" 2>/dev/null)
        if [ -n "$create_cmd" ]; then
            echo ""
            echo "Original create command:"
            echo "  $create_cmd"
        fi
    elif [ "$format" = "cli" ]; then
        build_cli_flags "$image"
    fi
}

# ============================================================================
# Recreate Command - Container recreation with feature changes
# ============================================================================

# Helper function to convert true/false to enabled/disabled for display
bool_to_status() {
    if [ "$1" = "true" ]; then
        echo "enabled"
    else
        echo "disabled"
    fi
}

# Build CLI flags from current feature state
# Assumes features have already been detected and variables are set
build_cli_flags() {
    local image="$1"
    local flags=()

    flags+=(--image "$image")

    if [ "${ENABLE_AUDIO:-false}" = true ]; then
        flags+=(--audio)
    fi
    if [ "${ENABLE_GPU:-false}" = true ]; then
        flags+=(--gpu)
    fi
    if [ "${ENABLE_INPUT:-false}" = true ]; then
        flags+=(--input)
    fi
    if [ "${ENABLE_DBUS:-false}" = true ]; then
        flags+=(--dbus)
    fi
    if [ "${ENABLE_DBUS_SYSTEM:-false}" = true ]; then
        flags+=(--dbus-system)
    fi
    if [ "${ENABLE_A11Y:-false}" = true ]; then
        flags+=(--a11y)
    fi
    if [ "${ENABLE_PODMAN:-false}" = true ]; then
        flags+=(--podman)
    fi
    if [ "${ENABLE_DISPLAY:-true}" = false ]; then
        flags+=(--no-display)
    fi
    # Only include --network if it's not the default
    if [ "${NETWORK_MODE:-default}" != "default" ]; then
        flags+=(--network "${NETWORK_MODE}")
    fi
    # Only include --systemd if it's set to a non-default value
    # Default is "true" (auto-detect) - omit it from CLI format
    # Show "always" (forced) and "false" (disabled) as they're explicit choices
    if [ -n "${SYSTEMD_MODE:-}" ] && [ "${SYSTEMD_MODE:-}" != "true" ]; then
        flags+=(--systemd "$SYSTEMD_MODE")
    fi

    if [ "${#USER_TMPFS[@]}" -gt 0 ] 2>/dev/null; then
        for tmpfs in "${USER_TMPFS[@]}"; do
            local tmpfs_path="${tmpfs%%:*}"
            flags+=(--tmpfs "$tmpfs_path")
        done
    fi

    if [ "${#DEVICES[@]}" -gt 0 ] 2>/dev/null; then
        for device in "${DEVICES[@]}"; do
            flags+=(--device "$device")
        done
    fi

    if [ "${#EXTRA_MOUNTS[@]}" -gt 0 ] 2>/dev/null; then
        for mount in "${EXTRA_MOUNTS[@]}"; do
            flags+=(-v "$mount")
        done
    fi

    echo "${flags[@]}"
}

# ==============================================================================
# CONTAINER INSPECT CACHE
# ==============================================================================
# Caches podman inspect output to avoid redundant calls during feature detection

# Cache variables (cleared by init_container_vars)
declare -g CONTAINER_INSPECT_CACHE=""
declare -g CONTAINER_INSPECT_CACHE_NAME=""

# cache_container_inspect - Cache full podman inspect output for performance
#
# Args:
#   $1 - container name
#
# Returns:
#   0 on success, 1 if container inspect fails
#
# Notes:
#   Caches result in CONTAINER_INSPECT_CACHE and CONTAINER_INSPECT_CACHE_NAME
#   Returns immediately if already cached for this container
#   Used by get_cached_label to avoid repeated podman calls
cache_container_inspect() {
    local container_name="$1"

    # Return cached result if we already inspected this container
    if [ "$CONTAINER_INSPECT_CACHE_NAME" = "$container_name" ] && [ -n "$CONTAINER_INSPECT_CACHE" ]; then
        return 0
    fi

    # Fetch and cache the full inspect output
    CONTAINER_INSPECT_CACHE=$(podman inspect "$container_name" 2>/dev/null) || {
        echo "Error: Failed to inspect container '$container_name'" >&2
        return 1
    }

    CONTAINER_INSPECT_CACHE_NAME="$container_name"
}

# Get a label value from the cached inspect data
# Falls back to direct podman inspect if cache is empty
#
# Args:
#   $1 - container name
#   $2 - label name (e.g., "cosy.audio")
#
# Returns:
#   The label value, or empty string if not found
get_cached_label() {
    local container_name="$1"
    local label_name="$2"

    # Ensure cache is populated
    cache_container_inspect "$container_name" || return 1

    # Extract label from cached JSON
    # This uses grep + sed which is faster than multiple podman calls
    # Use || true to ensure the pipeline succeeds even if label is not found
    echo "$CONTAINER_INSPECT_CACHE" | grep -o "\"$label_name\": *\"[^\"]*\"" | sed 's/.*: *"\([^"]*\)".*/\1/' | head -1 || true
}

# Get a config value using podman inspect
#
# Note: This does NOT use the cache because podman inspect doesn't support
# reading JSON from stdin. For frequently accessed values, consider adding
# specific parsing functions like we do for labels.
#
# Args:
#   $1 - container name
#   $2 - format string (e.g., "{{.HostConfig.NetworkMode}}")
#
# Returns:
#   The config value
get_cached_config() {
    local container_name="$1"
    local format="$2"

    podman inspect --format "$format" "$container_name" 2>/dev/null
}

# Clear the inspect cache
clear_inspect_cache() {
    CONTAINER_INSPECT_CACHE=""
    CONTAINER_INSPECT_CACHE_NAME=""
}

# ==============================================================================
# FEATURE DETECTION
# ==============================================================================

# Detect all features from an existing container
# This sets the global feature variables based on container labels and config
#
# Args:
#   $1 - container name to detect features from
#
# Side effects:
#   - Calls init_container_vars to reset state
#   - Sets COSY_CONTAINER_NAME
#   - Caches container inspect data
#   - Sets all ENABLE_* and other feature variables based on container config
detect_container_features() {
    local container_name="$1"

    init_container_vars
    COSY_CONTAINER_NAME="$container_name"

    # Pre-cache the container inspect data to avoid redundant calls
    cache_container_inspect "$container_name" || return 1

    for cap in "${FEATURES[@]}"; do
        # shellcheck disable=SC2086
        feature_${cap}_detect "$container_name"
    done

    # Detect intercepted flag states
    intercepted_systemd_detect "$container_name"
    intercepted_network_detect "$container_name"
    intercepted_detect "$container_name"
}

# Transfer writable layer from one container to another
# Uses podman unshare to access overlay storage as the correct user
transfer_writable_layer() {
    local src_container="$1"
    local dst_container="$2"

    echo "Transferring writable layer from '$src_container' to '$dst_container'..."

    # Verify both containers exist
    require_container_exists "$src_container"
    require_container_exists "$dst_container"

    # Verify both containers are stopped
    local src_state=$(podman inspect -f '{{.State.Status}}' "$src_container")
    local dst_state=$(podman inspect -f '{{.State.Status}}' "$dst_container")

    if [ "$src_state" != "configured" ] && [ "$src_state" != "exited" ] && [ "$src_state" != "stopped" ]; then
        echo "Error: Source container must be stopped (current state: $src_state)" >&2
        return 1
    fi

    if [ "$dst_state" != "configured" ] && [ "$dst_state" != "exited" ] && [ "$dst_state" != "stopped" ] && [ "$dst_state" != "created" ]; then
        echo "Error: Destination container must be stopped (current state: $dst_state)" >&2
        return 1
    fi

    # Verify overlay storage backend
    local src_driver=$(podman inspect -f '{{.GraphDriver.Name}}' "$src_container")
    local dst_driver=$(podman inspect -f '{{.GraphDriver.Name}}' "$dst_container")

    if [ "$src_driver" != "overlay" ]; then
        echo "Error: Source container must use overlay storage driver (found: $src_driver)" >&2
        return 1
    fi

    if [ "$dst_driver" != "overlay" ]; then
        echo "Error: Destination container must use overlay storage driver (found: $dst_driver)" >&2
        return 1
    fi

    # Check containers still exist before transfer (prevent race condition)
    if ! podman container exists "$src_container" 2>/dev/null; then
        echo "Error: Source container '$src_container' no longer exists" >&2
        return 1
    fi

    if ! podman container exists "$dst_container" 2>/dev/null; then
        echo "Error: Destination container '$dst_container' no longer exists" >&2
        return 1
    fi

    # Transfer using podman unshare to access the overlay directories
    podman unshare bash -c '
        set -euo pipefail

        # Get overlay directories
        SRC_UPPER=$(podman inspect -f "{{.GraphDriver.Data.UpperDir}}" "'"$src_container"'" 2>/dev/null) || {
            echo "Error: Failed to get source overlay directory for '"$src_container"'" >&2
            exit 1
        }

        DST_UPPER=$(podman inspect -f "{{.GraphDriver.Data.UpperDir}}" "'"$dst_container"'" 2>/dev/null) || {
            echo "Error: Failed to get destination overlay directory for '"$dst_container"'" >&2
            exit 1
        }

        # Validate directories exist and are not empty strings
        if [ -z "$SRC_UPPER" ]; then
            echo "Error: Source overlay directory path is empty" >&2
            exit 1
        fi

        if [ -z "$DST_UPPER" ]; then
            echo "Error: Destination overlay directory path is empty" >&2
            exit 1
        fi

        if [ ! -d "$SRC_UPPER" ]; then
            echo "Error: Source overlay directory does not exist: $SRC_UPPER" >&2
            exit 1
        fi

        if [ ! -d "$DST_UPPER" ]; then
            echo "Error: Destination overlay directory does not exist: $DST_UPPER" >&2
            exit 1
        fi

        # Verify source directory is readable
        if [ ! -r "$SRC_UPPER" ]; then
            echo "Error: Source overlay directory is not readable: $SRC_UPPER" >&2
            exit 1
        fi

        # Verify destination directory is writable
        if [ ! -w "$DST_UPPER" ]; then
            echo "Error: Destination overlay directory is not writable: $DST_UPPER" >&2
            exit 1
        fi

        # Transfer with tar to preserve all attributes, permissions, and special files
        # Explicit error handling for each step
        if ! cd "$SRC_UPPER"; then
            echo "Error: Failed to change to source directory: $SRC_UPPER" >&2
            exit 1
        fi

        if ! tar -cf - . | (cd "$DST_UPPER" && tar -xf -); then
            echo "Error: Failed to transfer data from $SRC_UPPER to $DST_UPPER" >&2
            exit 1
        fi
    ' || {
        echo "Error: Failed to transfer writable layer" >&2
        return 1
    }

    echo "Successfully transferred writable layer"
    return 0
}

# Copy container home directory for clone mode
copy_container_home() {
    local src_name="$1"
    local dst_name="$2"

    local src_home="${COSY_CONTAINER_HOMES_DIR}/${src_name}"
    local dst_home="${COSY_CONTAINER_HOMES_DIR}/${dst_name}"

    echo "Copying home directory from '$src_name' to '$dst_name'..."

    if [ ! -d "$src_home" ]; then
        echo "Source home directory does not exist, skipping copy"
        return 0
    fi

    mkdir -p "$dst_home"

    if command -v rsync >/dev/null 2>&1; then
        if ! rsync -a --exclude='.Xauthority' "$src_home/" "$dst_home/"; then
            echo "Error: Failed to copy home directory" >&2
            return 1
        fi
    else
        # Fallback to cp with find
        if ! (cd "$src_home" && find . -type d -exec mkdir -p "$dst_home/{}" \;); then
            echo "Error: Failed to copy home directory" >&2
            return 1
        fi
        if ! (cd "$src_home" && find . -type f ! -name '.Xauthority' -exec cp -p {} "$dst_home/{}" \;); then
            echo "Error: Failed to copy home directory" >&2
            return 1
        fi
    fi

    echo "Successfully copied home directory"
    return 0
}

# Show feature differences between current and requested configuration
show_feature_diff() {
    local container_name="$1"
    local mode="$2"  # "inplace" or "clone NEW_NAME"

    echo ""
    echo "Container Recreation Summary"
    echo "============================="
    echo ""

    if [ "$mode" = "inplace" ]; then
        echo "Mode: In-place recreation"
        echo "Container: $container_name"
    else
        local new_name="$3"
        echo "Mode: Clone"
        echo "Source: $container_name"
        echo "Destination: $new_name"
    fi

    echo ""
    echo "Current configuration:"
    echo "---------------------"

    # Save the requested "new" configuration before we re-detect the old one
    local new_audio="${ENABLE_AUDIO:-false}"
    local new_dbus="${ENABLE_DBUS:-false}"
    local new_dbus_system="${ENABLE_DBUS_SYSTEM:-false}"
    local new_display="${ENABLE_DISPLAY:-true}"
    local new_gpu="${ENABLE_GPU:-false}"
    local new_network="${NETWORK_MODE:-default}"
    local new_podman="${ENABLE_PODMAN:-false}"
    local new_systemd="${SYSTEMD_MODE:-false}"

    # Detect current features from the container (NOT in a subshell to preserve variables)
    detect_container_features "$container_name"

    # Get the image for CLI flags
    local old_image
    old_image=$(get_cached_config "$container_name" "{{.Config.Image}}")

    # Capture CLI flags now that features are detected
    local old_cli_flags
    old_cli_flags=$(build_cli_flags "$old_image")

    # Build detected_caps string for parsing
    local detected_caps
    detected_caps="DETECTED_AUDIO=${ENABLE_AUDIO:-false}
DETECTED_DBUS=${ENABLE_DBUS:-false}
DETECTED_DBUS_SYSTEM=${ENABLE_DBUS_SYSTEM:-false}
DETECTED_DISPLAY=${ENABLE_DISPLAY:-true}
DETECTED_GPU=${ENABLE_GPU:-false}
DETECTED_NETWORK=${NETWORK_MODE:-default}
DETECTED_PODMAN=${ENABLE_PODMAN:-false}
DETECTED_SYSTEMD=${SYSTEMD_MODE:-false}"

    # Parse detected features
    local old_audio="false"
    local old_dbus="false"
    local old_dbus_system="false"
    local old_display="true"
    local old_gpu="false"
    local old_network="default"
    local old_podman="false"
    local old_systemd="false"

    while IFS='=' read -r key value; do
        case "$key" in
            DETECTED_AUDIO) old_audio="$value" ;;
            DETECTED_DBUS) old_dbus="$value" ;;
            DETECTED_DBUS_SYSTEM) old_dbus_system="$value" ;;
            DETECTED_DISPLAY) old_display="$value" ;;
            DETECTED_GPU) old_gpu="$value" ;;
            DETECTED_NETWORK) old_network="$value" ;;
            DETECTED_PODMAN) old_podman="$value" ;;
            DETECTED_SYSTEMD) old_systemd="$value" ;;
        esac
    done <<< "$detected_caps"

    echo "  Audio: $(bool_to_status "$old_audio")"
    echo "  D-Bus (session): $(bool_to_status "$old_dbus")"
    echo "  D-Bus (system): $(bool_to_status "$old_dbus_system")"
    echo "  Display: $(bool_to_status "$old_display")"
    echo "  GPU: $(bool_to_status "$old_gpu")"
    echo "  Network mode: $old_network"
    echo "  Podman socket: $(bool_to_status "$old_podman")"
    echo "  Systemd: $old_systemd"

    # Show CLI flags for current config
    echo ""
    echo "  To create with current config:"
    echo "  cosy create $container_name $old_cli_flags"

    echo ""
    echo "Requested changes:"
    echo "------------------"

    local changes_found=false

    # Compare and show differences (new_* variables already saved at top of function)
    if [ "$old_audio" != "$new_audio" ]; then
        echo "  Audio: $(bool_to_status "$old_audio")  $(bool_to_status "$new_audio")"
        changes_found=true
    fi

    if [ "$old_gpu" != "$new_gpu" ]; then
        echo "  GPU: $(bool_to_status "$old_gpu")  $(bool_to_status "$new_gpu")"
        changes_found=true
    fi

    if [ "$old_dbus" != "$new_dbus" ]; then
        echo "  D-Bus (session): $(bool_to_status "$old_dbus")  $(bool_to_status "$new_dbus")"
        changes_found=true
    fi

    if [ "$old_dbus_system" != "$new_dbus_system" ]; then
        echo "  D-Bus (system): $(bool_to_status "$old_dbus_system")  $(bool_to_status "$new_dbus_system")"
        changes_found=true
    fi

    if [ "$old_display" != "$new_display" ]; then
        echo "  Display: $(bool_to_status "$old_display")  $(bool_to_status "$new_display")"
        changes_found=true
    fi

    if [ "$old_podman" != "$new_podman" ]; then
        echo "  Podman socket: $(bool_to_status "$old_podman")  $(bool_to_status "$new_podman")"
        changes_found=true
    fi

    if [ "$old_network" != "$new_network" ]; then
        echo "  Network mode: $old_network  $new_network"
        changes_found=true
    fi

    if [ "$old_systemd" != "$new_systemd" ]; then
        echo "  Systemd: $old_systemd  $new_systemd"
        changes_found=true
    fi

    if [ "$changes_found" = false ]; then
        echo "  (No changes detected)"
    fi

    echo ""
}

# handle_clone_impl - Core clone logic to duplicate container with new features
#
# Args:
#   $1 - source container name
#   $2 - destination container name
#
# Returns:
#   0 on success, 1 on error
#
# Notes:
#   Copies home directory from source to destination
#   Creates new container with current feature configuration
#   Transfers writable layer (filesystem changes) from source
#   Source container is stopped before transfer
#   Requires both containers to use overlay storage driver
handle_clone_impl() {
    local src_name="$1"
    local dst_name="$2"

    # Validate that source and destination are different
    if [ "$src_name" = "$dst_name" ]; then
        echo "Error: Source and destination must have different names" >&2
        echo "Use 'cosy recreate' to replace a container in place" >&2
        return 1
    fi

    echo "Cloning container '$src_name' to '$dst_name'..."

    # Check if source exists - if not, support create-if-missing if feature args provided
    if ! container_exists "$src_name"; then
        # Create-if-missing: if feature args were provided, create new container
        # This is determined by checking if any feature args exist in the caller context
        # For now, just error - the caller (handle_recreate) will handle create-if-missing
        echo "Error: Source container '$src_name' does not exist" >&2
        return 1
    fi

    require_container_not_exists "$dst_name"

    if ! copy_container_home "$src_name" "$dst_name"; then
        echo "Error: Failed to copy home directory" >&2
        return 1
    fi

    local src_image=$(get_cached_config "$src_name" "{{.ImageName}}")
    if [ -z "$src_image" ] || [ "$src_image" = "<none>" ]; then
        src_image=$(podman inspect -f '{{.Image}}' "$src_name")
    fi

    echo "Using image: $src_image"

    echo "Creating destination container with new features..."

    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would create container '$dst_name' from image '$src_image'"
        local build_result=0
    else
        # APP_HOME was already set by copy_container_home to use dst_name
        # Set COSY_CONTAINER_NAME so environment variables use the correct name
        COSY_CONTAINER_NAME="$dst_name"
        setup_all_features

        local create_flags=$(build_container_create_flags "$dst_name" "$src_image" "$CONTAINER_CMD" "$dst_name")
        # shellcheck disable=SC2086
        podman create $create_flags
        local build_result=$?
    fi

    if [ $build_result -ne 0 ]; then
        echo "Error: Failed to create destination container" >&2
        return 1
    fi

    local src_state=$(get_cached_config "$src_name" "{{.State.Status}}")
    if [ "$src_state" = "running" ]; then
        echo "Stopping source container..."
        if [ "$DRY_RUN" = false ]; then
            podman stop "$src_name" >/dev/null
        fi
    fi

    if [ "$DRY_RUN" = false ]; then
        if ! transfer_writable_layer "$src_name" "$dst_name"; then
            echo "Error: Failed to transfer writable layer" >&2
            echo "Cleaning up destination container..." >&2
            podman rm -f "$dst_name" >/dev/null 2>&1
            return 1
        fi
    else
        echo "[DRY RUN] Would transfer writable layer from '$src_name' to '$dst_name'"
    fi

    echo "Clone successful: '$src_name' cloned to '$dst_name'"
    return 0
}

# Main clone command handler
handle_clone() {
    local dest_container=""
    local show_diff_only=false
    local skip_confirmation=false
    local source_container=""

    # First pass: extract clone-specific flags
    local temp_args=()
    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h)
                show_clone_help
                ;;
            --show-diff)
                show_diff_only=true
                shift
                ;;
            --yes|-y)
                skip_confirmation=true
                shift
                ;;
            *)
                # Save for second pass
                temp_args+=("$1")
                shift
                ;;
        esac
    done

    set -- "${temp_args[@]}"
    local positional_args=()
    local feature_args=()

    while [ $# -gt 0 ]; do
        case "$1" in
            --network|--device|--volume|-v|--mount|--env|-e|--label|--annotation|--cap-add|--cap-drop|--security-opt|--tmpfs|--cmd|--systemd|--image)
                # Flags that take a value
                feature_args+=("$1")
                if [ $# -gt 1 ]; then
                    feature_args+=("$2")
                    shift 2
                else
                    shift
                fi
                ;;
            --network=*|--device=*|--volume=*|--mount=*|--env=*|--label=*|--annotation=*|--cap-add=*|--cap-drop=*|--security-opt=*|--tmpfs=*|--cmd=*|--systemd=*|--image=*)
                # Flags with = syntax
                feature_args+=("$1")
                shift
                ;;
            -*)
                feature_args+=("$1")
                shift
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    if [ ${#positional_args[@]} -ge 1 ]; then
        source_container="${positional_args[0]}"
    fi
    if [ ${#positional_args[@]} -ge 2 ]; then
        dest_container="${positional_args[1]}"
    fi
    if [ ${#positional_args[@]} -gt 2 ]; then
        echo "Error: Too many positional arguments" >&2
        echo "Usage: cosy clone [OPTIONS] SOURCE_CONTAINER DEST_CONTAINER" >&2
        return 1
    fi

    if [ -z "$source_container" ]; then
        echo "Error: Source container name required" >&2
        echo "Usage: cosy clone [OPTIONS] SOURCE_CONTAINER DEST_CONTAINER" >&2
        return 1
    fi

    if [ -z "$dest_container" ]; then
        echo "Error: Destination container name required" >&2
        echo "Usage: cosy clone [OPTIONS] SOURCE_CONTAINER DEST_CONTAINER" >&2
        return 1
    fi

    # Validate that source and dest are different
    if [ "$source_container" = "$dest_container" ]; then
        echo "Error: Source and destination must have different names" >&2
        echo "Use 'cosy recreate' to replace a container in place" >&2
        return 1
    fi

    # Check if source exists - if not, support create-if-missing
    if ! container_exists "$source_container"; then
        # Create-if-missing: if feature args were provided, create new container
        if [ ${#feature_args[@]} -eq 0 ]; then
            echo "Error: Source container '$source_container' does not exist" >&2
            echo "No container found and no options provided" >&2
            echo "Provide creation options to create a new container, or use 'cosy create' instead" >&2
            return 1
        else
            echo "Source container '$source_container' does not exist"
            echo "Creating new container with provided options..."

            local home_dir="${COSY_CONTAINER_HOMES_DIR}/${dest_container}"
            if [ -d "$home_dir" ]; then
                echo "Using existing home directory: $home_dir"
            fi

            init_container_vars
            COSY_CONTAINER_NAME="$dest_container"
            parse_container_args "${feature_args[@]}"
            apply_image_command_if_default

            setup_all_features
            run_podman_create

            echo "Container created successfully: $dest_container"
            return 0
        fi
    fi

    # Verify destination doesn't exist
    require_container_not_exists "$dest_container"

    echo "Detecting current container configuration..."
    detect_container_features "$source_container"

    init_container_vars

    parse_container_args "${feature_args[@]}"

    show_feature_diff "$source_container" "clone" "$dest_container"

    # Restore the new configuration after show_feature_diff (which resets vars to detect old config)
    init_container_vars
    parse_container_args "${feature_args[@]}"
    apply_image_command_if_default

    if [ "$show_diff_only" = true ]; then
        echo "Diff display only, not performing clone"
        return 0
    fi

    if [ "$skip_confirmation" = false ] && [ "$DRY_RUN" = false ]; then
        echo "Proceed with clone? [y/N] "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Clone cancelled"
            return 1
        fi
    fi

    handle_clone_impl "$source_container" "$dest_container"

    return $?
}

# handle_recreate_inplace - Replace container in-place with new features
#
# Args:
#   $1 - container name
#
# Returns:
#   0 on success, 1 on error
#
# Notes:
#   Creates temporary container with new features
#   Transfers writable layer from old to new container
#   Removes old container and renames new container to original name
#   Preserves home directory and filesystem changes
handle_recreate_inplace() {
    local container_name="$1"

    echo "Recreating container '$container_name' in place..."

    if ! podman container exists "$container_name"; then
        echo "Error: Container '$container_name' does not exist" >&2
        return 1
    fi

    # Preserve session ID from old container
    local preserved_session_id
    preserved_session_id=$(get_cached_label "$container_name" "cosy.session_id")
    if [ -z "$preserved_session_id" ] || [ "$preserved_session_id" = "<no value>" ]; then
        # Old container didn't have a session ID (created before this feature)
        preserved_session_id=$(generate_session_id)
    fi

    # Set the preserved session ID immediately for command history logging
    COMMAND_HISTORY_SESSION_ID="$preserved_session_id"

    local src_image=$(get_cached_config "$container_name" "{{.ImageName}}")
    if [ -z "$src_image" ] || [ "$src_image" = "<none>" ]; then
        src_image=$(command podman inspect -f '{{.Image}}' "$container_name")
    fi

    echo "Using image: $src_image"

    local container_state=$(get_cached_config "$container_name" "{{.State.Status}}")
    if [ "$container_state" = "running" ]; then
        echo "Stopping container..."
        if [ "$DRY_RUN" = false ]; then
            podman stop "$container_name" >/dev/null
        fi
    fi

    local old_temp_name="${container_name}-old-$$"

    if [ "$DRY_RUN" = false ]; then
        echo "Renaming original container..."
        podman rename "$container_name" "$old_temp_name" >/dev/null
    fi

    echo "Creating new container with updated features..."

    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would create new container '$container_name'"
        local build_result=0
    else
        COSY_CONTAINER_NAME="$container_name"
        # Add session ID to labels before setup_all_features
        LABEL_ARGS+=(--label "cosy.session_id=$preserved_session_id")
        setup_all_features

        APP_HOME="${COSY_CONTAINER_HOMES_DIR}/${container_name}"

        HOME_ARGS=(
            -e "COSY_CONTAINER_GID=$HOST_GID"
            -e "COSY_CONTAINER_HOME=/home/$HOST_USER"
            -e "COSY_CONTAINER_NAME=$COSY_CONTAINER_NAME"
            -e "COSY_CONTAINER_UID=$HOST_UID"
            -e "COSY_CONTAINER_USER=$HOST_USER"
            -e "HOME=/home/$HOST_USER"
            -e "USER=$HOST_USER"
            -v "$APP_HOME:/home/$HOST_USER$PRIVATE_LABEL"
        )

        local create_flags=$(build_container_create_flags "$container_name" "$src_image" "$CONTAINER_CMD" "$container_name")

        # shellcheck disable=SC2086
        podman create $create_flags
        local build_result=$?
    fi

    if [ $build_result -ne 0 ]; then
        echo "Error: Failed to create new container" >&2
        if [ "$DRY_RUN" = false ]; then
            echo "Restoring original container name..." >&2
            podman rename "$old_temp_name" "$container_name" >/dev/null 2>&1
        fi
        return 1
    fi

    if [ "$DRY_RUN" = false ]; then
        if ! transfer_writable_layer "$old_temp_name" "$container_name"; then
            echo "Error: Failed to transfer writable layer" >&2
            echo "Cleaning up new container and restoring original..." >&2
            podman rm -f "$container_name" >/dev/null 2>&1
            podman rename "$old_temp_name" "$container_name" >/dev/null 2>&1
            return 1
        fi

        echo "Verifying new configuration..."
        if ! podman start "$container_name" >/dev/null 2>&1; then
            echo "Error: New container configuration failed to start" >&2
            echo "Cleaning up new container and restoring original..." >&2
            podman rm -f "$container_name" >/dev/null 2>&1
            podman rename "$old_temp_name" "$container_name" >/dev/null 2>&1
            return 1
        fi
        podman stop "$container_name" >/dev/null 2>&1

        echo "Removing original container..."
        podman rm -f "$old_temp_name" >/dev/null
    else
        echo "[DRY RUN] Would transfer writable layer and replace '$container_name'"
    fi

    echo "Recreation successful"
    return 0
}

# Main recreate command handler - recreate existing container in place
handle_recreate() {
    local container_name=""
    local show_diff_only=false
    local skip_confirmation=false

    # First pass: extract recreate-specific flags
    local temp_args=()
    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h)
                show_recreate_help
                ;;
            --show-diff)
                show_diff_only=true
                shift
                ;;
            --yes|-y)
                skip_confirmation=true
                shift
                ;;
            *)
                # Save for second pass
                temp_args+=("$1")
                shift
                ;;
        esac
    done

    set -- "${temp_args[@]}"
    local positional_args=()
    local feature_args=()

    while [ $# -gt 0 ]; do
        case "$1" in
            --network|--device|--volume|-v|--mount|--env|-e|--label|--annotation|--cap-add|--cap-drop|--security-opt|--tmpfs|--cmd|--systemd|--image)
                # Flags that take a value
                feature_args+=("$1")
                if [ $# -gt 1 ]; then
                    feature_args+=("$2")
                    shift 2
                else
                    shift
                fi
                ;;
            --network=*|--device=*|--volume=*|--mount=*|--env=*|--label=*|--annotation=*|--cap-add=*|--cap-drop=*|--security-opt=*|--tmpfs=*|--cmd=*|--systemd=*|--image=*)
                # Flags with = syntax
                feature_args+=("$1")
                shift
                ;;
            -*)
                feature_args+=("$1")
                shift
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    if [ ${#positional_args[@]} -ge 1 ]; then
        container_name="${positional_args[0]}"
    fi
    if [ ${#positional_args[@]} -gt 1 ]; then
        echo "Error: Too many positional arguments" >&2
        echo "Usage: cosy recreate [OPTIONS] CONTAINER" >&2
        echo "To clone a container with a new name, use: cosy clone [OPTIONS] SOURCE DEST" >&2
        return 1
    fi

    require_container_name "$container_name" "Usage: cosy recreate [OPTIONS] CONTAINER"

    if ! container_exists "$container_name"; then
        # Container doesn't exist - check if we should create it
        if [ ${#feature_args[@]} -eq 0 ]; then
            echo "Error: Container '$container_name' does not exist" >&2
            echo "No container found and no options provided" >&2
            echo "Provide creation options to create a new container, or use 'cosy create' instead" >&2
            return 1
        else
            echo "Container '$container_name' does not exist"
            echo "Creating new container with provided options..."

            local home_dir="${COSY_CONTAINER_HOMES_DIR}/${container_name}"
            if [ -d "$home_dir" ]; then
                echo "Using existing home directory: $home_dir"
            fi

            init_container_vars
            COSY_CONTAINER_NAME="$container_name"
            parse_container_args "${feature_args[@]}"
            apply_image_command_if_default

            # Generate session ID for new container
            COMMAND_HISTORY_SESSION_ID=$(generate_session_id)
            LABEL_ARGS+=(--label "cosy.session_id=$COMMAND_HISTORY_SESSION_ID")

            setup_all_features
            run_podman_create

            echo "Container created successfully: $container_name"
            return 0
        fi
    fi

    echo "Detecting current container configuration..."
    detect_container_features "$container_name"

    init_container_vars
    parse_container_args "${feature_args[@]}"

    show_feature_diff "$container_name" "inplace"

    # Restore the new configuration after show_feature_diff (which resets vars to detect old config)
    init_container_vars
    parse_container_args "${feature_args[@]}"
    apply_image_command_if_default

    if [ "$show_diff_only" = true ]; then
        echo "Diff display only, not performing recreation"
        return 0
    fi

    if [ "$skip_confirmation" = false ] && [ "$DRY_RUN" = false ]; then
        echo "Proceed with recreation? [y/N] "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Recreation cancelled"
            return 1
        fi
    fi

    handle_recreate_inplace "$container_name"

    return $?
}

# ==============================================================================
# NETWORK COMMAND HELPERS
# ==============================================================================

# validate_network_container - Validate container for network operations
#
# Args:
#   $1 - container name
#   $2 - require_running (optional, default: true)
#
# Returns:
#   0 if valid, exits with error otherwise
validate_network_container() {
    local container="$1"
    local require_running="${2:-true}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        return 1
    fi

    validate_container_name "$container" || return 1

    require_container_exists "$container"

    if [ "$require_running" = "true" ]; then
        if [ "$(podman container inspect -f '{{.State.Running}}' "$container")" != "true" ]; then
            echo "Error: Container '$container' not running" >&2
            echo "Start it first with: cosy enter $container" >&2
            return 1
        fi
    fi

    return 0
}

# check_network_tools - Check for required network tools on host
#
# Args:
#   $@ - list of required tools (e.g., "tc" "nsenter" "ss")
#
# Returns:
#   0 if all tools available, exits with error otherwise
check_network_tools() {
    local missing=()

    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing+=("$tool")
        fi
    done

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Required tool(s) not available on host: ${missing[*]}" >&2
        echo "" >&2
        echo "Install missing tools:" >&2

        for tool in "${missing[@]}"; do
            case "$tool" in
                tc)
                    echo "  Fedora/RHEL: sudo dnf install -y iproute tc" >&2
                    ;;
                nsenter)
                    echo "  Fedora/RHEL: sudo dnf install -y util-linux" >&2
                    ;;
                ss|ip)
                    echo "  Fedora/RHEL: sudo dnf install -y iproute" >&2
                    ;;
                tcpdump)
                    echo "  Fedora/RHEL: sudo dnf install -y tcpdump" >&2
                    ;;
                *)
                    echo "  $tool: check your distribution's package manager" >&2
                    ;;
            esac
        done
        return 1
    fi

    return 0
}

# get_container_network_interfaces - Get non-loopback interfaces from container
#
# Args:
#   $1 - container name
#
# Outputs:
#   Space-separated list of interface names to stdout
#
# Returns:
#   0 on success, 1 if no interfaces found
get_container_network_interfaces() {
    local container="$1"
    local interfaces

    interfaces=$(run_in_container_netns "$container" ip -o link show 2>/dev/null | grep -v "lo:" | awk '{print $2}' | sed 's/:$//')

    if [ -z "$interfaces" ]; then
        echo "Error: No network interfaces found in container" >&2
        return 1
    fi

    echo "$interfaces"
    return 0
}

handle_network_inspect() {
    container="${1:-}"
    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network inspect <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1

    # Disable set -e for this case to be fault-tolerant with different network modes
    set +e

    echo "Container: $container"
    echo "============================================"
    echo ""

    # Network mode
    network_mode=$(podman inspect -f '{{.HostConfig.NetworkMode}}' "$container")
    echo "Network Mode: $network_mode"

    # Network names
    network_names=$(podman inspect -f '{{range $k, $v := .NetworkSettings.Networks}}{{$k}} {{end}}' "$container" 2>/dev/null | xargs)
    if [ -n "$network_names" ]; then
        echo "Networks: $network_names"
    fi

    # IP address
    ip_address=$(podman inspect -f '{{.NetworkSettings.IPAddress}}' "$container" 2>/dev/null || echo "N/A")
    if [ -z "$ip_address" ] || [ "$ip_address" = "<no value>" ]; then
        ip_address=$(podman inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$container" 2>/dev/null || echo "N/A")
    fi
    echo "IP Address: $ip_address"

    # Gateway
    gateway=$(podman inspect -f '{{.NetworkSettings.Gateway}}' "$container" 2>/dev/null || echo "N/A")
    if [ -z "$gateway" ] || [ "$gateway" = "<no value>" ]; then
        gateway=$(podman inspect -f '{{range .NetworkSettings.Networks}}{{.Gateway}}{{end}}' "$container" 2>/dev/null || echo "N/A")
    fi
    echo "Gateway: $gateway"

    # DNS servers
    dns_servers=$(podman inspect -f '{{range .NetworkSettings.Networks}}{{range .DNSServerIPs}}{{.}} {{end}}{{end}}' "$container" 2>/dev/null)
    if [ -z "$dns_servers" ]; then
        dns_servers=$(podman inspect -f '{{join .HostConfig.DNS ", "}}' "$container" 2>/dev/null || echo "N/A")
    fi
    echo "DNS Servers: ${dns_servers:-N/A}"

    echo ""

    # Active connections count
    # Use a subshell to prevent set -e from causing early exit
    (
        connection_count=$(run_in_container_netns "$container" ss -tunap 2>/dev/null | grep -vc "^State" 2>/dev/null || echo "N/A")
        if [ "$connection_count" = "N/A" ] || [ -z "$connection_count" ]; then
            echo "Active Connections: N/A (requires ss on host)"
        else
            echo "Active Connections: $connection_count"
        fi
    ) || echo "Active Connections: N/A"

    # Bandwidth from /proc/net/dev
    # Use a subshell to prevent set -e from causing early exit
    (
        netdev_output=$(run_in_container_netns "$container" cat /proc/net/dev 2>/dev/null || echo "")

        if [ -n "$netdev_output" ]; then
            # Parse receive and transmit bytes (usually eth0, but check all non-lo interfaces)
            rx_bytes=0
            tx_bytes=0
            while IFS= read -r line; do
                if echo "$line" | grep -q ":"; then
                    iface=$(echo "$line" | awk -F: '{print $1}' | tr -d ' ')
                    if [ "$iface" != "lo" ]; then
                        line_rx=$(echo "$line" | awk '{print $2}')
                        line_tx=$(echo "$line" | awk '{print $10}')
                        # Only add if values are numeric
                        if [[ "$line_rx" =~ ^[0-9]+$ ]] && [[ "$line_tx" =~ ^[0-9]+$ ]]; then
                            rx_bytes=$((rx_bytes + line_rx))
                            tx_bytes=$((tx_bytes + line_tx))
                        fi
                    fi
                fi
            done <<< "$netdev_output"

            # Convert to human readable (only if values are valid)
            if command -v numfmt >/dev/null 2>&1 && [ "$rx_bytes" -ge 0 ] 2>/dev/null && [ "$tx_bytes" -ge 0 ] 2>/dev/null; then
                rx_human=$(numfmt --to=iec-i --suffix=B "$rx_bytes" 2>/dev/null || echo "${rx_bytes} bytes")
                tx_human=$(numfmt --to=iec-i --suffix=B "$tx_bytes" 2>/dev/null || echo "${tx_bytes} bytes")
            else
                rx_human="${rx_bytes:-0} bytes"
                tx_human="${tx_bytes:-0} bytes"
            fi

            echo "Total Bandwidth: $rx_human received, $tx_human transmitted"
        fi
    ) || true

    # Re-enable set -e and exit successfully
    set -e
    exit 0
}

handle_network_stats() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network stats <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools nsenter || exit 1

    # Get container PID
    container_pid=$(get_container_pid "$container")
    if [ -z "$container_pid" ] || [ "$container_pid" = "0" ]; then
        echo "Error: Could not get PID for container '$container'" >&2
        exit 1
    fi

    # Read from /proc/<pid>/net/dev from host
    netdev_output=$(cat "/proc/$container_pid/net/dev" 2>/dev/null)

    if [ -z "$netdev_output" ]; then
        echo "Error: Could not read network stats from container" >&2
        exit 1
    fi

    echo "Network Statistics: $container"
    echo "============================================"
    printf "%-12s %15s %15s %12s %12s\n" "Interface" "RX Bytes" "TX Bytes" "RX Packets" "TX Packets"
    echo "--------------------------------------------------------------------"

    while IFS= read -r line; do
        if echo "$line" | grep -q ":"; then
            iface=$(echo "$line" | awk -F: '{print $1}' | tr -d ' ')
            # Parse columns from /proc/net/dev
            # Format: bytes packets errs drop fifo frame compressed multicast
            line_data=$(echo "$line" | awk -F: '{print $2}')
            rx_bytes=$(echo "$line_data" | awk '{print $1}')
            rx_packets=$(echo "$line_data" | awk '{print $2}')
            tx_bytes=$(echo "$line_data" | awk '{print $9}')
            tx_packets=$(echo "$line_data" | awk '{print $10}')

            # Convert to human readable if numfmt available and values are numeric
            if command -v numfmt >/dev/null 2>&1 && [[ "$rx_bytes" =~ ^[0-9]+$ ]] && [[ "$tx_bytes" =~ ^[0-9]+$ ]]; then
                rx_bytes_human=$(numfmt --to=iec-i --suffix=B "$rx_bytes" 2>/dev/null || echo "$rx_bytes")
                tx_bytes_human=$(numfmt --to=iec-i --suffix=B "$tx_bytes" 2>/dev/null || echo "$tx_bytes")
            else
                rx_bytes_human="${rx_bytes:-0}"
                tx_bytes_human="${tx_bytes:-0}"
            fi

            printf "%-12s %15s %15s %12s %12s\n" "$iface" "${rx_bytes_human}" "${tx_bytes_human}" "${rx_packets:-0}" "${tx_packets:-0}"
        fi
    done <<< "$netdev_output"
}

handle_network_connections() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network connections <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools ss nsenter || exit 1

    echo "Active Connections: $container"
    echo "============================================"
    echo ""

    # Use host's ss command via nsenter
    run_in_container_netns "$container" ss -tunap 2>/dev/null || echo "No active connections"
}

handle_network_watch() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network watch <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools ss nsenter || exit 1

    echo "Watching connections for container: $container"
    echo "Press Ctrl+C to stop"
    echo ""

    # Store previous connections state
    prev_connections=""

    # Set up trap to clean up on exit
    trap 'echo ""; echo "Monitoring stopped"; exit 0' INT TERM

    while true; do
        # Get current connections
        curr_connections=$(run_in_container_netns "$container" ss -tunap 2>/dev/null | grep -E "^(tcp|udp)" | grep -v "^State" | sort || echo "")

        if [ -n "$prev_connections" ]; then
            # Find new connections (in current but not in previous)
            new_connections=$(comm -13 <(echo "$prev_connections") <(echo "$curr_connections"))

            if [ -n "$new_connections" ]; then
                # Parse and display new connections
                while IFS= read -r line; do
                    if [ -n "$line" ]; then
                        # Extract protocol, local, and remote addresses
                        proto=$(echo "$line" | awk '{print $1}')
                        local_addr=$(echo "$line" | awk '{print $5}')
                        remote_addr=$(echo "$line" | awk '{print $6}')
                        state=$(echo "$line" | awk '{print $2}')

                        timestamp=$(date '+%H:%M:%S')
                        echo "[$timestamp] $proto $local_addr -> $remote_addr ($state)"
                    fi
                done <<< "$new_connections"
            fi
        fi

        # Update previous state
        prev_connections="$curr_connections"

        # Wait before next check
        sleep "$NETWORK_WATCH_POLL_SEC"
    done
}

handle_network_list() {
    echo "=== Podman Networks ==="
    echo ""

    if ! command -v podman >/dev/null 2>&1; then
        echo "Error: podman command not found" >&2
        exit 1
    fi

    # Get all networks
    networks=$(podman network ls --format "{{.Name}}" 2>/dev/null)

    if [ -z "$networks" ]; then
        echo "No networks found"
        exit 0
    fi

    # For each network, find cosy containers connected to it
    while IFS= read -r network; do
        # Get containers on this network
        containers_on_network=$(podman network inspect "$network" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null)

        # Filter for cosy containers (those with homes in COSY_CONTAINER_HOMES_DIR)
        cosy_containers=""
        for container in $containers_on_network; do
            if [ -d "$COSY_CONTAINER_HOMES_DIR/$container" ]; then
                cosy_containers="$cosy_containers$container "
            fi
        done

        # Only show networks with cosy containers
        if [ -n "$cosy_containers" ]; then
            # Get network details
            subnet=$(podman network inspect "$network" --format '{{range .Subnets}}{{.Subnet}}{{end}}' 2>/dev/null)

            echo "Network: $network"
            echo "  Subnet: ${subnet:-N/A}"
            echo "  Cosy Containers:$cosy_containers"
            echo ""
        fi
    done <<< "$networks"
}

handle_network_disconnect() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network disconnect <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools ip nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    # Save network configuration before disconnecting
    mkdir -p "$COSY_CONTAINER_HOMES_DIR/$container"
    local config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-state"
    true > "$config_file"  # Clear the file

    echo "Disconnecting network for container: $container"
    for iface in $interfaces; do
        # Save IP addresses
        run_in_container_netns "$container" ip -o addr show "$iface" >> "$config_file"
        # Save routes
        run_in_container_netns "$container" ip -o route show dev "$iface" >> "$config_file"

        echo "  Bringing down interface: $iface"
        if ! run_in_container_netns "$container" ip link set "$iface" down 2>/dev/null; then
            echo "Error: Failed to bring down interface $iface" >&2
            exit 1
        fi
    done

    echo "Network disconnected successfully"
}

handle_network_reconnect() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network reconnect <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools ip nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    echo "Reconnecting network for container: $container"

    # Bring up each interface
    for iface in $interfaces; do
        echo "  Bringing up interface: $iface"
        if ! run_in_container_netns "$container" ip link set "$iface" up 2>/dev/null; then
            echo "Error: Failed to bring up interface $iface" >&2
            exit 1
        fi
    done

    # Restore saved network configuration if it exists
    local config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-state"
    if [ -f "$config_file" ]; then
        echo "  Restoring network configuration..."

        # Parse and restore IP addresses
        while IFS= read -r line; do
            if [[ "$line" =~ inet[6]?[[:space:]] ]]; then
                # Extract interface name and IP/mask
                local iface
                local ip_info
                iface=$(echo "$line" | awk '{print $2}')
                ip_info=$(echo "$line" | awk '{for(i=4;i<=NF;i++) if($i~/^[0-9]/) {print $i; break}}')

                if [ -n "$ip_info" ] && [[ ! "$ip_info" =~ ^127\. ]]; then
                    echo "    Restoring IP: $ip_info on $iface"
                    run_in_container_netns "$container" ip addr add "$ip_info" dev "$iface" 2>/dev/null || true
                fi
            elif [[ "$line" =~ ^(default|[0-9]) ]]; then
                # This is a route line
                local route_dev
                route_dev=$(echo "$line" | grep -oP 'dev \K\S+' || echo "")
                if [ -n "$route_dev" ]; then
                    echo "    Restoring route: $line"
                    run_in_container_netns "$container" ip route add "$line" 2>/dev/null || true
                fi
            fi
        done < "$config_file"

        rm -f "$config_file"
    else
        echo "  Warning: No saved network configuration found"
        echo "  Interface is up but IP configuration may need to be restored manually"
    fi

    echo "Network reconnected successfully"
}

handle_network_throttle() {
    # Parse arguments for --persist flag
    persist=false
    container=""
    bandwidth=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --persist)
                persist=true
                shift
                ;;
            *)
                if [ -z "$container" ]; then
                    container="${1:-}"
                elif [ -z "$bandwidth" ]; then
                    bandwidth="${1:-}"
                else
                    echo "Error: Unexpected argument '$1'" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$container" ] || [ -z "$bandwidth" ]; then
        echo "Error: Missing required arguments" >&2
        echo "Usage: cosy network throttle <container> <bandwidth> [--persist]" >&2
        echo "Example: cosy network throttle myapp 1mbit" >&2
        echo "Example: cosy network throttle myapp 1mbit --persist" >&2
        exit 1
    fi

    # Validate bandwidth format (e.g., 1mbit, 512kbit, 100kbit)
    if ! [[ "$bandwidth" =~ ^[0-9]+(kbit|mbit|gbit|kbps|mbps|gbps)$ ]]; then
        echo "Error: Invalid bandwidth format '$bandwidth'" >&2
        echo "Valid formats: 1mbit, 512kbit, 100kbps, etc." >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools tc nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    # Apply bandwidth limit to each interface
    echo "Applying bandwidth limit: $bandwidth to container: $container"
    for iface in $interfaces; do
        echo "  Configuring interface: $iface"

        # Remove existing qdisc if present
        run_quiet run_in_container_netns "$container" tc qdisc del dev "$iface" root || true

        # Add token bucket filter (tbf) to limit bandwidth
        run_quiet run_in_container_netns "$container" tc qdisc add dev "$iface" root tbf rate "$bandwidth" burst 32kbit latency 400ms || {
            echo "Error: Failed to apply bandwidth limit to interface $iface" >&2
            exit 1
        }
    done

    # Save to config if --persist
    if [ "$persist" = true ]; then
        network_config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-config"

        # Create or update config file
        if [ -f "$network_config_file" ]; then
            # Remove old NETWORK_BANDWIDTH_LIMIT line if present
            sed -i '/^NETWORK_BANDWIDTH_LIMIT=/d' "$network_config_file"
        fi

        printf "NETWORK_BANDWIDTH_LIMIT=%s\n" "$bandwidth" >> "$network_config_file"
        echo "Bandwidth limit saved and will persist across container restarts"
    else
        echo "Bandwidth limit applied (temporary - will reset on container restart)"
    fi

    echo "Bandwidth limit configured successfully"
}

handle_network_delay() {
    # Parse arguments for --persist flag
    persist=false
    container=""
    delay=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --persist)
                persist=true
                shift
                ;;
            *)
                if [ -z "$container" ]; then
                    container="${1:-}"
                elif [ -z "$delay" ]; then
                    delay="${1:-}"
                else
                    echo "Error: Unexpected argument '$1'" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$container" ] || [ -z "$delay" ]; then
        echo "Error: Missing required arguments" >&2
        echo "Usage: cosy network delay <container> <milliseconds> [--persist]" >&2
        echo "Example: cosy network delay myapp 100ms" >&2
        echo "Example: cosy network delay myapp 100ms --persist" >&2
        exit 1
    fi

    # Validate delay format (e.g., 100ms, 1s)
    if ! [[ "$delay" =~ ^[0-9]+(ms|s)$ ]]; then
        echo "Error: Invalid delay format '$delay'" >&2
        echo "Valid formats: 100ms, 1s, etc." >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools tc nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    # Apply delay to each interface
    echo "Adding network delay: $delay to container: $container"
    for iface in $interfaces; do
        echo "  Configuring interface: $iface"

        # Remove existing qdisc if present
        run_quiet run_in_container_netns "$container" tc qdisc del dev "$iface" root || true

        # Add network emulator (netem) to add delay
        run_quiet run_in_container_netns "$container" tc qdisc add dev "$iface" root netem delay "$delay" || {
            echo "Error: Failed to add delay to interface $iface" >&2
            exit 1
        }
    done

    # Save to config if --persist
    if [ "$persist" = true ]; then
        network_config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-config"

        # Create or update config file
        if [ -f "$network_config_file" ]; then
            # Remove old NETWORK_DELAY line if present
            sed -i '/^NETWORK_delay=/d' "$network_config_file"
        fi

        printf "NETWORK_delay=%s\n" "$delay" >> "$network_config_file"
        echo "Network delay saved and will persist across container restarts"
    else
        echo "Network delay applied (temporary - will reset on container restart)"
    fi

    echo "Network delay configured successfully"
}

handle_network_loss() {
    # Parse arguments for --persist flag
    container=""
    loss=""
    persist=false

    while [ $# -gt 0 ]; do
        case "$1" in
            --persist)
                persist=true
                shift
                ;;
            *)
                if [ -z "$container" ]; then
                    container="${1:-}"
                elif [ -z "$loss" ]; then
                    loss="$1"
                else
                    echo "Error: Unknown argument '$1'" >&2
                    echo "Usage: cosy network loss <container> <percentage> [--persist]" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$container" ] || [ -z "$loss" ]; then
        echo "Error: Missing required arguments" >&2
        echo "Usage: cosy network loss <container> <percentage> [--persist]" >&2
        echo "Example: cosy network loss myapp 5%" >&2
        echo "Example: cosy network loss myapp 5% --persist" >&2
        exit 1
    fi

    # Validate loss format (e.g., 5%, 10%)
    if ! [[ "$loss" =~ ^[0-9]+(\.[0-9]+)?%$ ]]; then
        echo "Error: Invalid packet loss format '$loss'" >&2
        echo "Valid formats: 5%, 10%, 2.5%, etc." >&2
        exit 1
    fi

    # Extract percentage value
    loss_pct="${loss%\%}"

    # Validate range (0-100) using pure bash
    # Handle both integer and decimal values
    if [[ "$loss_pct" =~ \. ]]; then
        # Decimal value - multiply by 10 to compare (e.g., 2.5 -> 25, 100.0 -> 1000)
        local loss_int="${loss_pct%.*}"
        local loss_dec="${loss_pct#*.}"
        # Pad or trim decimal to 1 digit
        loss_dec="${loss_dec:0:1}"
        local loss_scaled=$((loss_int * 10 + loss_dec))

        if [ "$loss_scaled" -lt 0 ] || [ "$loss_scaled" -gt 1000 ]; then
            echo "Error: Packet loss percentage must be between 0 and 100 (got: $loss_pct)" >&2
            exit 1
        fi
    else
        # Integer value - direct comparison
        if [ "$loss_pct" -lt 0 ] || [ "$loss_pct" -gt 100 ]; then
            echo "Error: Packet loss percentage must be between 0 and 100 (got: $loss_pct)" >&2
            exit 1
        fi
    fi

    validate_network_container "$container" || exit 1
    check_network_tools tc nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    # Apply packet loss to each interface
    echo "Simulating packet loss: $loss to container: $container"
    for iface in $interfaces; do
        echo "  Configuring interface: $iface"

        # Remove existing qdisc if present
        run_quiet run_in_container_netns "$container" tc qdisc del dev "$iface" root || true

        # Add network emulator (netem) to simulate packet loss
        if ! run_quiet run_in_container_netns "$container" tc qdisc add dev "$iface" root netem loss "$loss"; then
            echo "Error: Failed to simulate packet loss on interface $iface" >&2
            exit 1
        fi
    done

    # Save to config if --persist
    if [ "$persist" = true ]; then
        network_config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-config"

        # Create or update config file
        if [ -f "$network_config_file" ]; then
            # Remove old NETWORK_LOSS line if present
            sed -i '/^NETWORK_loss=/d' "$network_config_file"
            sed -i '/^NETWORK_LOSS_HOST_SIDE=/d' "$network_config_file"
        fi

        printf "NETWORK_loss=%s\n" "$loss" >> "$network_config_file"
        printf "NETWORK_LOSS_HOST_SIDE=true\n" >> "$network_config_file"
        echo "Packet loss simulation saved and will persist across container restarts"
    else
        echo "Packet loss simulation applied (temporary - will reset on container restart)"
    fi

    echo "Packet loss simulation configured successfully"
}

handle_network_reset() {
    container="${1:-}"

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network reset <container>" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools tc nsenter || exit 1
    interfaces=$(get_container_network_interfaces "$container") || exit 1

    # Remove all traffic shaping from each interface
    echo "Resetting traffic shaping for container: $container"
    for iface in $interfaces; do
        echo "  Resetting interface: $iface"
        run_in_container_netns "$container" tc qdisc del dev "$iface" root 2>/dev/null || true
    done

    # Clear persisted settings
    network_config_file="$COSY_CONTAINER_HOMES_DIR/$container/.cosy-network-config"
    if [ -f "$network_config_file" ]; then
        sed -i '/^NETWORK_BANDWIDTH_LIMIT=/d' "$network_config_file"
        sed -i '/^NETWORK_BANDWIDTH_LIMIT_HOST_SIDE=/d' "$network_config_file"
        sed -i '/^NETWORK_delay=/d' "$network_config_file"
        sed -i '/^NETWORK_DELAY_HOST_SIDE=/d' "$network_config_file"
        sed -i '/^NETWORK_loss=/d' "$network_config_file"
        sed -i '/^NETWORK_LOSS_HOST_SIDE=/d' "$network_config_file"

        # Remove file if now empty
        if [ ! -s "$network_config_file" ]; then
            rm -f "$network_config_file"
        fi

        echo "Cleared persisted traffic shaping settings"
    fi

    echo "Traffic shaping reset successfully"
}

handle_network_capture() {
    container="${1:-}"
    output_file="${2:-}"

    # Set default output file if not specified
    if [ -z "$output_file" ]; then
        output_file="/tmp/${container}-$(date +%Y%m%d-%H%M%S).pcap"
    fi

    if [ -z "$container" ]; then
        echo "Error: No container specified" >&2
        echo "Usage: cosy network capture <container> [output-file]" >&2
        echo "Example: cosy network capture myapp /tmp/traffic.pcap" >&2
        exit 1
    fi

    validate_network_container "$container" || exit 1
    check_network_tools tcpdump nsenter || exit 1

    echo "Starting packet capture for container: $container"
    echo "Output file: $output_file"
    echo "Press Ctrl+C to stop capture"
    echo ""

    # Set up trap to show summary on exit and fix file ownership
    # Inside podman unshare, UID 0 maps to the host user, so chown to 0:0
    trap 'echo ""; echo "Capture stopped"; podman unshare chown 0:0 "$output_file" 2>/dev/null || true; echo "Packets saved to: $output_file"; exit 0' INT TERM

    # Run tcpdump from host in container's network namespace
    run_in_container_netns "$container" tcpdump -i any -w "$output_file" 2>/dev/null

    # If we get here without interrupt, tcpdump exited (shouldn't happen normally)
    # Fix ownership of the output file (it was created in podman unshare namespace)
    # Inside podman unshare, UID 0 maps to the host user
    podman unshare chown 0:0 "$output_file" 2>/dev/null || true
    echo "Capture complete: $output_file"
}

handle_network() {
    action="${1:-}"

    if [ -z "$action" ] || [ "$action" = "--help" ] || [ "$action" = "-h" ]; then
        cat <<EOF
Usage: cosy network <action> [arguments]

Inspection:
  connections <container>            List active network connections
  inspect <container>                Show network configuration and statistics
  list                               List all networks and connected containers
  stats <container>                  Display bandwidth statistics
  watch <container>                  Monitor new connections in real-time

Control:
  disconnect <container>             Disable all networking for container
  reconnect <container>              Re-enable networking for container

Traffic Shaping:
  delay <container> <milliseconds> [--persist]   Add latency to connections
  loss <container> <percentage> [--persist]      Simulate packet loss
  reset <container>                              Remove all traffic shaping
  throttle <container> <bandwidth> [--persist]   Limit bandwidth (e.g., 1mbit, 512kbit)

Advanced:
  capture <container> [output-file]  Capture network traffic to pcap file

Note:
  All network monitoring and control commands use host-side tools (podman unshare +
  nsenter, tc, ss, tcpdump) to operate without installing tools in the container.
  This works in rootless mode and prevents container code from interfering with
  monitoring.

Examples:
  cosy network capture myapp /tmp/traffic.pcap
  cosy network connections browser
  cosy network delay myapp 100ms --persist
  cosy network disconnect untrusted-app
  cosy network inspect myapp
  cosy network list
  cosy network loss myapp 5% --persist
  cosy network reconnect untrusted-app
  cosy network reset myapp
  cosy network stats photo-editor
  cosy network throttle myapp 1mbit --persist
  cosy network watch browser
EOF
        exit 1
    fi

    shift  # Remove action from args

    case "$action" in
        inspect)
            handle_network_inspect "$@"
            ;;

        stats)
            handle_network_stats "$@"
            ;;

        connections)
            handle_network_connections "$@"
            ;;

        watch)
            handle_network_watch "$@"
            ;;

        list)
            handle_network_list "$@"
            ;;

        disconnect)
            handle_network_disconnect "$@"
            ;;

        reconnect)
            handle_network_reconnect "$@"
            ;;

        throttle)
            handle_network_throttle "$@"
            ;;

        delay)
            handle_network_delay "$@"
            ;;

        loss)
            handle_network_loss "$@"
            ;;

        reset)
            handle_network_reset "$@"
            ;;

        capture)
            handle_network_capture "$@"
            ;;

        *)
            echo "Error: Unknown action '$action'" >&2
            echo "Run 'cosy network' for usage information" >&2
            exit 1
            ;;
    esac
}


handle_desktop() {
    local action="${1:-}"

    if [ -z "$action" ] || [ "$action" = "--help" ] || [ "$action" = "-h" ]; then
        cat <<EOF
Usage: cosy desktop <action> [arguments]

Actions:
  create <container> [options] -- <command...>    Create desktop entry
  ls|list                                         List all desktop entries
  rm <container>                                  Remove desktop entry
  install                                         Update desktop database

Desktop Entry Creation Options:
  --name "Name"              Application name (default: container name)
  --icon icon-name           Icon name or path
  --comment "Description"    Application description
  --categories "Cat1;Cat2"   Desktop categories (default: "Utility;")
  --mime-types "mime/type"   MIME types (semicolon-separated)
  --terminal                 Run in terminal
  --no-startup-notify        Disable startup notification

Examples:
  # Create Firefox launcher
  cosy desktop create firefox --name "Firefox" --icon firefox -- firefox

  # Create Firefox safe mode launcher
  cosy desktop create firefox --name "Safe Mode" -- firefox --safe-mode

  # Create terminal launcher
  cosy desktop create devenv --terminal --name "Dev Env" -- bash

  # List all desktop entries
  cosy desktop ls

  # Remove desktop entry
  cosy desktop rm firefox

  # Update desktop database
  cosy desktop install

Notes:
  - Desktop entries are automatically removed with 'cosy rm --home <container>'
  - Desktop files are placed in ~/.local/share/applications/
  - Metadata is stored in ~/.local/share/cosy/<container>/.desktop-metadata
  - The '--' separator is required before the command
EOF
        exit 1
    fi

    shift  # Remove action from args

    case "$action" in
        create)
            handle_desktop_create "$@"
            ;;
        ls|list)
            handle_desktop_list "$@"
            ;;
        rm|remove)
            handle_desktop_rm "$@"
            ;;
        install)
            handle_desktop_install "$@"
            ;;
        *)
            echo "Error: Unknown action '$action'" >&2
            echo "Run 'cosy desktop' for usage information" >&2
            exit 1
            ;;
    esac
}

handle_desktop_create() {
    local container=""
    local name=""
    local icon=""
    local comment=""
    local categories="Utility;"
    local mime_types=""
    local terminal="false"
    local startup_notify="true"
    local command_parts=()
    local found_separator=false

    # First positional arg is container name
    require_container_name "${1:-}" "Usage: cosy desktop create <container> [options] -- <command>"
    container="$1"
    shift

    # Validate container name
    validate_container_name "$container" || exit 1

    # Parse options until we hit '--' separator
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --)
                found_separator=true
                shift
                # Everything remaining is the command
                command_parts=("$@")
                break
                ;;
            --name)
                if [ -z "${2:-}" ] || [ "${2}" = "--" ]; then
                    echo "Error: --name requires an argument" >&2
                    exit 1
                fi
                name="$2"
                shift 2
                ;;
            --icon)
                if [ -z "${2:-}" ] || [ "${2}" = "--" ]; then
                    echo "Error: --icon requires an argument" >&2
                    exit 1
                fi
                icon="$2"
                shift 2
                ;;
            --comment)
                if [ -z "${2:-}" ] || [ "${2}" = "--" ]; then
                    echo "Error: --comment requires an argument" >&2
                    exit 1
                fi
                comment="$2"
                shift 2
                ;;
            --categories)
                if [ -z "${2:-}" ] || [ "${2}" = "--" ]; then
                    echo "Error: --categories requires an argument" >&2
                    exit 1
                fi
                categories="$2"
                shift 2
                ;;
            --mime-types)
                if [ -z "${2:-}" ] || [ "${2}" = "--" ]; then
                    echo "Error: --mime-types requires an argument" >&2
                    exit 1
                fi
                mime_types="$2"
                shift 2
                ;;
            --terminal)
                terminal="true"
                shift
                ;;
            --no-startup-notify)
                startup_notify="false"
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                echo "Run 'cosy desktop' for usage information" >&2
                echo "Note: Use '--' before the command, e.g.: cosy desktop create <container> [options] -- <command>" >&2
                exit 1
                ;;
        esac
    done

    # Validate that we found the separator
    if [ "$found_separator" = false ]; then
        echo "Error: Missing '--' separator before command" >&2
        echo "Usage: cosy desktop create <container> [options] -- <command>" >&2
        echo "Example: cosy desktop create firefox --name Firefox -- firefox" >&2
        exit 1
    fi

    # Validate that command was provided
    if [ ${#command_parts[@]} -eq 0 ]; then
        echo "Error: Command required after '--'" >&2
        echo "Usage: cosy desktop create <container> [options] -- <command>" >&2
        exit 1
    fi

    # Join command parts into a single string
    local command="${command_parts[*]}"

    # Default name to container name if not provided
    if [ -z "$name" ]; then
        name="$container"
    fi

    # Warn if container doesn't exist (but proceed)
    if ! podman container exists "$container" 2>/dev/null; then
        echo "Warning: Container '$container' does not exist" >&2
        echo "Creating desktop entry anyway (container can be created later)" >&2
        echo ""
    fi

    # Ensure directories exist
    mkdir -p "$(get_desktop_metadata_dir "$container")"
    mkdir -p "$HOME/.local/share/applications"

    # Generate desktop file content
    local desktop_file
    desktop_file=$(get_desktop_file_path "$container")
    local exec_line="cosy run $container $command"

    # Add %F or %U for MIME types
    if [ -n "$mime_types" ]; then
        # %U for URLs (scheme handlers), %F for files
        if [[ "$mime_types" =~ x-scheme-handler ]]; then
            exec_line+=" %U"
        else
            exec_line+=" %F"
        fi
    fi

    # Write desktop file
    cat > "$desktop_file" <<EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=$(desktop_escape "$name")
Exec=$exec_line
Terminal=$terminal
StartupNotify=$startup_notify
Categories=$categories
EOF

    # Add optional fields
    if [ -n "$icon" ]; then
        echo "Icon=$icon" >> "$desktop_file"
    fi

    if [ -n "$comment" ]; then
        echo "Comment=$(desktop_escape "$comment")" >> "$desktop_file"
    fi

    if [ -n "$mime_types" ]; then
        echo "MimeType=$mime_types" >> "$desktop_file"
    fi

    # Store metadata as JSON
    local metadata_file
    metadata_file=$(get_desktop_metadata_file "$container")
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$metadata_file" <<EOF
{
  "version": "1.0",
  "container": "$(json_escape "$container")",
  "command": "$(json_escape "$command")",
  "desktop_file": "$(json_escape "$desktop_file")",
  "created_at": "$timestamp",
  "modified_at": "$timestamp",
  "name": "$(json_escape "$name")",
  "icon": "$(json_escape "$icon")",
  "comment": "$(json_escape "$comment")",
  "categories": "$(json_escape "$categories")",
  "mime_types": "$(json_escape "$mime_types")",
  "terminal": $terminal,
  "startup_notify": $startup_notify
}
EOF

    echo "Desktop entry created: $desktop_file"
    echo "Metadata saved: $metadata_file"
    echo ""
    echo "Run 'cosy desktop install' to update desktop database"
}

handle_desktop_list() {
    # Find all desktop metadata files
    local found_any=false

    if [ ! -d "${COSY_CONTAINER_HOMES_DIR}" ]; then
        echo "No desktop entries found"
        return 0
    fi

    echo "Desktop Entries:"
    echo "================"
    echo ""

    for container_dir in "${COSY_CONTAINER_HOMES_DIR}"/*; do
        if [ ! -d "$container_dir" ]; then
            continue
        fi

        local container
        container=$(basename "$container_dir")
        local metadata_file
        metadata_file=$(get_desktop_metadata_file "$container")

        if [ ! -f "$metadata_file" ]; then
            continue
        fi

        found_any=true

        # Parse JSON metadata (basic parsing without jq dependency)
        local name command created_at desktop_file
        name=$(grep '"name"' "$metadata_file" | sed 's/.*: "\(.*\)",*/\1/')
        command=$(grep '"command"' "$metadata_file" | sed 's/.*: "\(.*\)",*/\1/')
        created_at=$(grep '"created_at"' "$metadata_file" | sed 's/.*: "\(.*\)",*/\1/')
        desktop_file=$(grep '"desktop_file"' "$metadata_file" | sed 's/.*: "\(.*\)",*/\1/')

        echo "Container: $container"
        echo "  Name: $name"
        echo "  Command: $command"
        echo "  Created: $created_at"
        echo "  Desktop file: $desktop_file"

        # Check if desktop file actually exists
        if [ -f "$desktop_file" ]; then
            echo "  Status: Active"
        else
            echo "  Status: Missing (run 'cosy desktop create' to recreate)"
        fi
        echo ""
    done

    if [ "$found_any" = false ]; then
        echo "No desktop entries found"
        echo ""
        echo "Create one with: cosy desktop create <container> [options] -- <command>"
    fi
}

handle_desktop_rm() {
    local container="${1:-}"

    require_container_name "$container" "Usage: cosy desktop rm <container>"

    validate_container_name "$container" || exit 1

    local metadata_file
    metadata_file=$(get_desktop_metadata_file "$container")
    local desktop_file
    desktop_file=$(get_desktop_file_path "$container")

    if [ ! -f "$metadata_file" ]; then
        echo "Error: No desktop entry found for container '$container'" >&2
        exit 1
    fi

    # Remove files
    rm -f "$desktop_file" 2>/dev/null || true
    rm -f "$metadata_file" 2>/dev/null || true

    echo "Removed desktop entry for: $container"
    echo "  Desktop file: $desktop_file"
    echo "  Metadata: $metadata_file"
    echo ""
    echo "Run 'cosy desktop install' to update desktop database"
}

handle_desktop_install() {
    # Update desktop database if update-desktop-database is available
    if command -v update-desktop-database >/dev/null 2>&1; then
        echo "Updating desktop database..."
        update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
        echo "Desktop database updated"
    else
        echo "Note: update-desktop-database not found"
        echo "Desktop entries may not appear immediately in application menus"
        echo ""
        echo "Install desktop-file-utils package for automatic database updates:"
        echo "  Fedora/RHEL: sudo dnf install -y desktop-file-utils"
    fi
}

handle_completion() {
    local shell_type="${1:-}"

    if [ -z "$shell_type" ]; then
        echo "Error: Shell type required" >&2
        echo "Usage: cosy completion SHELL" >&2
        echo "" >&2
        echo "Supported shells:" >&2
        echo "  bash    Generate bash completion script" >&2
        echo "  zsh     Generate zsh completion script" >&2
        exit 1
    fi

    case "$shell_type" in
        bash)
            cat <<'EOF'
# Bash completion for cosy
_cosy() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Main commands
    local commands="create run enter list ls rm stop inspect recreate network desktop completion"

    # If we're completing the first argument, suggest commands
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
        return 0
    fi

    # Get the main command
    local cmd="${COMP_WORDS[1]}"

    case "${cmd}" in
        create|run)
            # Suggest flags and existing home directories/containers
            if [[ ${cur} == -* ]]; then
                # Try to use podman's completion if available
                if declare -F _podman >/dev/null 2>&1; then
                    # Temporarily modify COMP_WORDS to call podman completion
                    local save_words=("${COMP_WORDS[@]}")
                    COMP_WORDS=(podman "${cmd}" "${cur}")
                    COMP_CWORD=2
                    _podman
                    COMP_WORDS=("${save_words[@]}")
                    COMP_CWORD=${#COMP_WORDS[@]}-1

                    # Add cosy-specific flags to what podman suggested
                    local cosy_flags="--audio --gpu --input --dbus --dbus-system --a11y --podman --no-display --sudo --root"
                    COMPREPLY+=( $(compgen -W "${cosy_flags}" -- ${cur}) )
                else
                    # Podman completion not available, just show cosy flags
                    local cosy_flags="--audio --gpu --input --dbus --dbus-system --a11y --podman --no-display --sudo --root"
                    COMPREPLY=( $(compgen -W "${cosy_flags}" -- ${cur}) )
                fi
            else
                if [ "${cmd}" = "create" ]; then
                    # Suggest existing home directories (can recreate containers with existing homes)
                    local homes_dir="${COSY_HOMES_DIR:-$HOME/.local/share/cosy}"
                    local homes=""
                    if [ -d "$homes_dir" ]; then
                        homes=$(find "$homes_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort)
                    fi
                    COMPREPLY=( $(compgen -W "${homes}" -- ${cur}) )
                else
                    # run command - suggest containers
                    local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
                fi
            fi
            ;;
        list|ls)
            # No arguments for list
            ;;
        rm)
            # Suggest --home flag, containers, and orphaned homes
            if [[ ${cur} == -* ]]; then
                COMPREPLY=( $(compgen -W "--home" -- ${cur}) )
            else
                local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                local homes_dir="${COSY_HOMES_DIR:-$HOME/.local/share/cosy}"
                local homes=""
                if [ -d "$homes_dir" ]; then
                    homes=$(find "$homes_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort)
                fi
                # Combine containers and homes (deduplicate via sort -u)
                local all_names=$(echo -e "${containers}\n${homes}" | sort -u)
                COMPREPLY=( $(compgen -W "${all_names}" -- ${cur}) )
            fi
            ;;
        stop|inspect)
            # Suggest container names
            local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
            COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
            ;;
        enter)
            # Suggest --root flag and container names
            if [[ ${cur} == -* ]]; then
                COMPREPLY=( $(compgen -W "--root" -- ${cur}) )
            else
                local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
            fi
            ;;
        recreate)
            # Suggest flags and container names
            if [[ ${cur} == -* ]]; then
                # Cosy feature flags + recreate-specific flags (not intercepted podman flags)
                local flags="--show-diff --yes --audio --gpu --input --dbus --dbus-system --a11y --podman --no-display --sudo"
                COMPREPLY=( $(compgen -W "${flags}" -- ${cur}) )
            else
                local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
            fi
            ;;
        clone)
            # Suggest flags and container names
            if [[ ${cur} == -* ]]; then
                # Cosy feature flags + clone-specific flags (not intercepted podman flags)
                local flags="--show-diff --yes --audio --gpu --input --dbus --dbus-system --a11y --podman --no-display --sudo"
                COMPREPLY=( $(compgen -W "${flags}" -- ${cur}) )
            else
                local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
            fi
            ;;
        network)
            # Suggest network subcommands
            if [ $COMP_CWORD -eq 2 ]; then
                COMPREPLY=( $(compgen -W "create connect disconnect list throttle delay loss" -- ${cur}) )
            fi
            ;;
        desktop)
            # Suggest desktop subcommands
            if [ $COMP_CWORD -eq 2 ]; then
                COMPREPLY=( $(compgen -W "create ls list rm remove install" -- ${cur}) )
            elif [ $COMP_CWORD -eq 3 ]; then
                case "${COMP_WORDS[2]}" in
                    create)
                        # Suggest container names for create
                        local containers=$(podman ps -a --filter "label=cosy.managed=true" --format "{{.Names}}" 2>/dev/null)
                        COMPREPLY=( $(compgen -W "${containers}" -- ${cur}) )
                        ;;
                    rm|remove)
                        # Suggest containers with desktop entries
                        local desktop_containers=""
                        if [ -d "${COSY_CONTAINER_HOMES_DIR:-$HOME/.local/share/cosy}" ]; then
                            for d in "${COSY_CONTAINER_HOMES_DIR:-$HOME/.local/share/cosy}"/*/.desktop-metadata; do
                                if [ -f "$d" ]; then
                                    local parent_dir
                                    parent_dir=$(dirname "$d")
                                    desktop_containers+="$(basename "$parent_dir") "
                                fi
                            done
                        fi
                        COMPREPLY=( $(compgen -W "${desktop_containers}" -- ${cur}) )
                        ;;
                esac
            fi
            ;;
        completion)
            # Suggest shell types
            if [ $COMP_CWORD -eq 2 ]; then
                COMPREPLY=( $(compgen -W "bash zsh" -- ${cur}) )
            fi
            ;;
    esac
}

complete -F _cosy cosy
EOF
            ;;
        zsh)
            cat <<'EOF'
#compdef cosy

_cosy() {
    local -a commands
    commands=(
        'clone:Clone a container with a new name'
        'completion:Generate shell completion script'
        'create:Create a new container'
        'desktop:Manage desktop entries'
        'enter:Enter a container interactively'
        'inspect:Inspect container configuration'
        'list:List all cosy containers'
        'ls:List all cosy containers'
        'network:Manage container networks'
        'recreate:Recreate a container in place with new features'
        'rm:Remove a container'
        'run:Run a command in a container (create if needed)'
        'stop:Stop a container'
    )

    _arguments -C \
        '1: :->command' \
        '*:: :->args'

    case $state in
        command)
            _describe 'command' commands
            ;;
        args)
            case $words[1] in
                create)
                    # Always show cosy flags + delegate to podman if available
                    _arguments \
                        '--a11y[Enable accessibility bus]' \
                        '--audio[Enable audio (/dev/snd + sockets)]' \
                        '--dbus-system[Enable D-Bus system]' \
                        '--dbus[Enable D-Bus session]' \
                        '--gpu[Enable GPU passthrough]' \
                        '--sudo[Enable passwordless sudo access]' \
                        '--input[Enable input device passthrough]' \
                        '--no-display[Disable display]' \
                        '--podman[Enable Podman socket]' \
                        '*:name:_cosy_homes'

                    # If podman completion is available, also suggest its flags
                    if (( $+functions[_podman] )); then
                        _podman
                    fi
                    ;;
                run)
                    # Always show cosy flags + delegate to podman if available
                    _arguments \
                        '--a11y[Enable accessibility bus]' \
                        '--audio[Enable audio (/dev/snd + sockets)]' \
                        '--dbus-system[Enable D-Bus system]' \
                        '--dbus[Enable D-Bus session]' \
                        '--gpu[Enable GPU passthrough]' \
                        '--sudo[Enable passwordless sudo access]' \
                        '--input[Enable input device passthrough]' \
                        '--no-display[Disable display]' \
                        '--podman[Enable Podman socket]' \
                        '--root[Run as root user]'

                    # If podman completion is available, also suggest its flags
                    if (( $+functions[_podman] )); then
                        _podman
                    fi
                    ;;
                enter)
                    _arguments \
                        '--root[Enter as root user]' \
                        '*:container:_cosy_containers'
                    ;;
                list|ls)
                    # No arguments
                    ;;
                rm)
                    _arguments \
                        '--home[Remove home directory]' \
                        '*:container:_cosy_containers_and_homes'
                    ;;
                stop|inspect)
                    _arguments '*:container:_cosy_containers'
                    ;;
                recreate|clone)
                    _arguments \
                        '--a11y[Enable accessibility bus]' \
                        '--audio[Enable audio]' \
                        '--dbus-system[Enable D-Bus system]' \
                        '--dbus[Enable D-Bus session]' \
                        '--gpu[Enable GPU]' \
                        '--sudo[Enable passwordless sudo access]' \
                        '--input[Enable input devices]' \
                        '--network[Network mode]:mode:(default host none)' \
                        '--no-display[Disable display]' \
                        '--podman[Enable Podman socket]' \
                        '--show-diff[Show diff only]' \
                        '--systemd[Enable systemd]:mode:(true always false)' \
                        '--yes[Skip confirmation]' \
                        '*:container:_cosy_containers'
                    ;;
                network)
                    _arguments '1:action:(create connect disconnect list throttle delay loss)'
                    ;;
                desktop)
                    _arguments \
                        '1:action:(create ls list rm remove install)' \
                        '2:container:_cosy_containers' \
                        '3:command:' \
                        '--name[Application name]:name:' \
                        '--icon[Icon name]:icon:' \
                        '--comment[Description]:comment:' \
                        '--categories[Categories]:categories:' \
                        '--mime-types[MIME types]:mime:' \
                        '--terminal[Run in terminal]' \
                        '--no-startup-notify[Disable startup notification]'
                    ;;
                completion)
                    _arguments '1:shell:(bash zsh)'
                    ;;
            esac
            ;;
    esac
}

_cosy_containers() {
    local -a containers
    containers=(${(f)"$(podman ps -a --filter 'label=cosy.managed=true' --format '{{.Names}}' 2>/dev/null)"})
    _describe 'container' containers
}

_cosy_homes() {
    local -a homes
    local homes_dir="${COSY_HOMES_DIR:-$HOME/.local/share/cosy}"
    if [ -d "$homes_dir" ]; then
        homes=(${(f)"$(find "$homes_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort)"})
    fi
    _describe 'home directory' homes
}

_cosy_containers_and_homes() {
    local -a items
    local containers=$(podman ps -a --filter 'label=cosy.managed=true' --format '{{.Names}}' 2>/dev/null)
    local homes_dir="${COSY_HOMES_DIR:-$HOME/.local/share/cosy}"
    local homes=""
    if [ -d "$homes_dir" ]; then
        homes=$(find "$homes_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort)
    fi
    items=(${(f)"$(echo -e "$containers\n$homes" | sort -u)"})
    _describe 'container or home' items
}

_cosy "$@"
EOF
            ;;
        *)
            echo "Error: Unknown shell type: $shell_type" >&2
            echo "Supported shells: bash, zsh" >&2
            exit 1
            ;;
    esac
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
    if [[ $# -eq 0 ]]; then
        # Show help when no command is specified
        cat <<'EOF'
cosy - Container management tool

Usage: cosy [--dry-run] [--debug] COMMAND [OPTIONS] [ARGS...]

Subcommands:
  clone      Clone a container with a new name
  completion Generate shell completion script (bash, zsh)
  create     Create a new container
  desktop    Desktop application launcher management
  enter      Enter an existing container, creating if needed
  inspect    Inspect container configuration
  list, ls   List all cosy containers
  network    Network management and monitoring
  recreate   Recreate a container in place with new features
  rm         Remove a container
  run        Run command in container, creating if needed
  stop       Stop a container

Global Options:
  --dry-run            Show commands without executing
  --debug              Show debug information

Options (for create/run):
  --a11y               Enable accessibility bus (AT-SPI)
  --audio              Enable audio (/dev/snd + sockets)
  --dbus               Enable D-Bus session bus
  --dbus-system        Enable D-Bus system bus
  --gpu                Enable GPU passthrough
  --input              Enable input device passthrough (joysticks, gamepads, etc.)
  --image, -i          Base image (default: $COSY_DEFAULT_IMAGE)
  --no-display         Disable display passthrough (enabled by default)
  --podman             Enable Podman socket passthrough

Examples:
  cosy create mybox                      # Create container
  cosy run mybox                         # Run bash in container
  cosy run --gpu mybox python script.py  # Run with GPU
  cosy enter mybox                       # Enter existing container
  cosy rm --home mybox                   # Remove container and home dir

For more information: https://github.com/BenSmith/cosy
EOF
        exit 0
    fi

    # Capture original command for labeling
    ORIGINAL_COMMAND_ARGS=("$@")

    # Initialize command history logging variables
    COMMAND_HISTORY_INVOCATION_ID=$(generate_invocation_id)
    COMMAND_HISTORY_SEQUENCE=0
    COMMAND_HISTORY_SESSION_ID=""  # Will be set per container
    COMMAND_HISTORY_COSY_COMMAND=""  # Will be set after parsing subcommand
    COMMAND_HISTORY_COSY_ARGS=""  # Will be set after parsing
    COMMAND_HISTORY_IMAGE=""  # Will be set during container operations
    COMMAND_HISTORY_IMAGE_ID=""  # Will be set during container operations
    COMMAND_HISTORY_FEATURES=""  # Will be set during container operations

    # Parse global flags before subcommand
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --debug)
                DEBUG=true
                shift
                ;;
            --version|-V)
                echo "cosy version $COSY_VERSION"
                exit 0
                ;;
            --help|-h|help)
                cat <<'EOF'
cosy - Container management tool

Usage: cosy [--dry-run] [--debug] COMMAND [OPTIONS] [ARGS...]

Subcommands:
  clone      Clone a container with a new name
  completion Generate shell completion script (bash, zsh)
  create     Create a new container
  desktop    Desktop application launcher management
  enter      Enter an existing container, creating if needed
  inspect    Inspect container configuration
  list, ls   List all cosy containers
  network    Network management and monitoring
  recreate   Recreate a container in place with new features
  rm         Remove a container
  run        Run command in container, creating if needed
  stop       Stop a container

Global Options:
  --dry-run            Show commands without executing
  --debug              Show debug information

Options (for create/run):
  --a11y               Enable accessibility bus (AT-SPI)
  --audio              Enable audio (/dev/snd + sockets)
  --dbus               Enable D-Bus session bus
  --dbus-system        Enable D-Bus system bus
  --gpu                Enable GPU passthrough
  --input              Enable input device passthrough (joysticks, gamepads, etc.)
  --image, -i          Base image (default: $COSY_DEFAULT_IMAGE)
  --no-display         Disable display passthrough (enabled by default)
  --podman             Enable Podman socket passthrough

Examples:
  cosy create mybox                      # Create container
  cosy run mybox                         # Run bash in container
  cosy run --gpu mybox python script.py  # Run with GPU
  cosy enter mybox                       # Enter existing container
  cosy rm --home mybox                   # Remove container and home dir

For more information: https://github.com/BenSmith/cosy
EOF
                exit 0
                ;;
            -*)
                echo "Error: Unknown global flag '$1'" >&2
                exit 1
                ;;
            *)
                # Not a global flag, must be subcommand
                break
                ;;
        esac
    done

    SUBCOMMAND="${1:-}"
    shift || true

    case "$SUBCOMMAND" in
        create|run|enter|list|ls|rm|stop|inspect|recreate|clone|network|desktop|completion)
            ;;
        *)
            echo "Error: Unknown subcommand '$SUBCOMMAND'" >&2
            echo "Run 'cosy --help' for usage information" >&2
            exit 1
            ;;
    esac

    # Set command history variables for logging
    COMMAND_HISTORY_COSY_COMMAND="$SUBCOMMAND"
    # Convert command args to JSON array
    COMMAND_HISTORY_COSY_ARGS="["
    for ((i=0; i<${#ORIGINAL_COMMAND_ARGS[@]}; i++)); do
        if [ $i -gt 0 ]; then
            COMMAND_HISTORY_COSY_ARGS+=","
        fi
        # Escape quotes and backslashes in JSON string
        local escaped_arg="${ORIGINAL_COMMAND_ARGS[$i]//\\/\\\\}"
        escaped_arg="${escaped_arg//\"/\\\"}"
        COMMAND_HISTORY_COSY_ARGS+="\"$escaped_arg\""
    done
    COMMAND_HISTORY_COSY_ARGS+="]"

    if is_container_subcommand; then
        init_container_vars
    fi

    case "$SUBCOMMAND" in
        create)
            handle_create "$@"
            ;;
        run)
            handle_run "$@"
            ;;
        enter)
            handle_enter "$@"
            ;;
        list|ls)
            handle_list "$@"
            ;;
        rm)
            handle_rm "$@"
            ;;
        stop)
            handle_stop "$@"
            ;;
        inspect)
            handle_inspect "$@"
            ;;
        recreate)
            handle_recreate "$@"
            ;;
        clone)
            handle_clone "$@"
            ;;
        network)
            handle_network "$@"
            ;;
        desktop)
            handle_desktop "$@"
            ;;
        completion)
            handle_completion "$@"
            ;;
    esac
}

# Call main with all arguments
main "$@"
